<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Listado de videos 2026</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #c62828;
            text-align: center;
        }
        
        /* Estilos de tabla eliminados - ahora usamos divs con CSS Grid */
        
        /* Componente flotante de progreso de generaci√≥n de video */
        #video-generation-progress-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }
        
        .video-progress-item {
            background: white;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #667eea;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .video-progress-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }
        
        .video-progress-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .video-progress-bar-container {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }
        
        .video-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .video-progress-text {
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .video-progress-status {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
        
        .video-progress-item.completed {
            border-left-color: #4caf50;
        }
        
        .video-progress-item.error {
            border-left-color: #f44336;
        }
        
        /* Estructura de divs para reemplazar tabla */
        .videos-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        
        .videos-body {
            display: flex;
            flex-direction: column;
        }
        
        .video-row {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s;
            align-items: start;
        }
        
        .video-row-wrapper {
            border-bottom: 3px solid #333;
        }
        
        .video-row:hover {
            background-color: #f5f5f5;
        }
        
        .video-row.has-group:hover {
            background: #9e9e9e;
        }
        
        .video-cell {
            padding: 10px 8px;
            border-right: 1px solid #e0e0e0;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex-shrink: 0;
            max-height: 135px;
        }
        
        /* La columna del t√≠tulo usa todo el espacio disponible */
        .title-cell {
            flex: 1;
            min-width: 200px;
        }
        
        .video-cell:last-child {
            border-right: none;
        }
        
        .thumbnail-cell {
            text-align: center;
            width: 225px;
        }
        
        .thumbnail {
            max-height: 110px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            
            object-fit: cover;
        }
        
        .thumbnail-placeholder {
            width: 188px;
            height: 125px;
            background: #e0e0e0;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 12px;
            margin: 5px;
        }
        
        .title {
            font-weight: 600;            
            color: #333;
            line-height: 1.5;
            max-height: calc(1.5em * 3); /* 3 l√≠neas */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            text-overflow: ellipsis;
            word-wrap: break-word;
        }
        
        .description {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
            max-height: calc(1.5em * 3); /* 3 l√≠neas */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            text-overflow: ellipsis;
            word-wrap: break-word;
        }
        
        /* Columna de selecci√≥n */
        .select-column {
            width: 120px;
            text-align: center;
            padding-left: 0px;
            padding-right: 0px;
        }
        
        .selection-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }
        
        .selection-checkbox:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        .update-content-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        
        .update-content-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .update-content-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Dar m√°s espacio a la columna Fecha */
        .videos-header .video-cell:nth-child(7),
        .video-row .video-cell:nth-child(7) {
            min-width: 120px;
            white-space: nowrap;
        }
        
        .theme {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin: 2px;
        }
        
        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 5px;
        }
        
        .tag {
            display: inline-block;
            background: #f5f5f5;
            color: #666;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 11px;
        }
        
        .youtube-link {
            color: #ff0000;
            text-decoration: none;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .youtube-link:hover {
            text-decoration: underline;
        }
        
        .caller-info {
            font-size: 14px;
        }
        
        .caller-name {
            font-weight: 600;
            color: #333;
        }
        
        .caller-age {
            color: #666;
        }
        
        .date {
            color: #666;
            font-size: 14px;
        }
        
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .delete-btn:hover {
            background: #d32f2f;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .delete-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .blacklist-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .blacklist-btn:hover {
            background: #f57c00;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .blacklist-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .edit-metadata-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .edit-metadata-btn:hover {
            background: #7B1FA2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .edit-metadata-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .pinecone-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .pinecone-btn:hover:not(:disabled) {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .pinecone-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .revalidate-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .revalidate-btn:hover:not(:disabled) {
            background: #1976D2;
        }
        
        .revalidate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .metadata-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }
        
        .metadata-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .metadata-modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .metadata-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .metadata-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }
        
        .metadata-modal-filename {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
            font-family: monospace;
            word-break: break-all;
        }
        
        .metadata-modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .metadata-modal-close:hover,
        .metadata-modal-close:focus {
            color: #000;
        }
        
        .metadata-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 400px;
            margin-bottom: 15px;
        }
        
        .metadata-editor {
            width: 100%;
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: #1e1e1e;
            color: #d4d4d4;
            resize: vertical;
            tab-size: 2;
            line-height: 1.5;
        }
        
        .metadata-editor:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .metadata-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .metadata-save-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .metadata-save-btn:hover {
            background: #45a049;
        }
        
        .metadata-cancel-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .metadata-cancel-btn:hover {
            background: #d32f2f;
        }
        
        .prompt-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }
        
        .prompt-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .prompt-modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .prompt-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .prompt-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }
        
        .prompt-modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .prompt-modal-close:hover,
        .prompt-modal-close:focus {
            color: #000;
        }
        
        .prompt-modal-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .prompt-copy-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .prompt-copy-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .prompt-copy-btn:active {
            transform: translateY(0);
        }
        
        .prompt-copy-btn.copied {
            background: #4CAF50;
        }
        
        .prompt-content {
            flex: 1;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: #f9f9f9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            max-height: calc(90vh - 150px);
            color: #333;
        }
        
        .prompt-empty {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }
        
        .regenerate-title-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .regenerate-title-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .regenerate-title-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .generate-video-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .generate-video-btn:hover {
            background: #7B1FA2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .generate-video-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .generate-short-btn {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .generate-short-btn:hover {
            background: #EE5A5A;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .generate-short-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .title-editable {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .title-editable:hover {
            background-color: #f0f0f0;
        }
        
        .title-editing {
            background-color: #fff;
            border: 2px solid #2196F3;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            min-width: 300px;
            min-height: 60px;
            max-height: 200px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            overflow-y: auto;
        }
        
        .title-editing:focus {
            outline: none;
            border-color: #1976D2;
        }
        
        .action-cell {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            align-items: start;
            justify-items: stretch;
        }
        
        .action-cell button {
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            height: 30px;
        }
        
        .action-cell button .icon {
            flex-shrink: 0;
            font-size: 18px;
        }
        
        .action-cell button .text {
            flex: 1;
            text-align: left;
        }
        
        /* Asegurar que la celda de acciones se muestre en la fila adicional */
        .additional-row .action-cell {
            vertical-align: top;
            padding: 5px;
        }
        
        .controls {
            background: #f5f5f5;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .stats-info {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-left: auto;
        }
        
        .switch-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .switch-label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #667eea;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .thumbnail-original-column {
            transition: opacity 0.3s, width 0.3s;
        }
        
        .thumbnail-original-column.hidden {
            display: none;
        }
        
        .thumbnail-container {
            position: relative;
            display: inline-block;
        }
        
        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .generate-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .thumbnail-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 6px;
            display: none;
        }
        
        .thumbnail-loading.active {
            display: block;
        }
        
        .thumbnail-loading .spinner {
            width: 20px;
            height: 20px;
            border-width: 2px;
            margin: 0 auto 5px;
        }
        
        .thumbnail-loading p {
            font-size: 10px;
            margin: 0;
            color: #333;
        }
        
        /* Modal para mostrar imagen completa */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s;
        }
        
        .image-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .image-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            margin: auto;
            animation: zoomIn 0.3s;
        }
        
        @keyframes zoomIn {
            from { transform: scale(0.7); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .image-modal img {
            width: 100%;
            height: auto;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .image-modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        
        .image-modal-close:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        .thumbnail-clickable {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .thumbnail-clickable:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .video-details-container {
            background: #f9f9f9;
            padding: 15px;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            border-top: 1px solid #e0e0e0;
        }
        
        .video-details-container.collapsed {
            display: none;
        }
        
        /* Cuando est√° colapsado, ocultar todas las celdas excepto la del t√≠tulo */
        .video-row.collapsed .video-cell:not(.title-cell) {
            display: none;
        }
        
        .video-row.collapsed .title-cell {
            flex: 1;
            width: 100%;
        }
        
        /* Cuando est√° colapsado, ocultar ID de YouTube y descripci√≥n, solo mostrar t√≠tulo y bot√≥n */
        .video-row.collapsed .title-container > div:first-child {
            display: none !important;
        }
        
        .video-row.collapsed .title-container .description {
            display: none !important;
        }
        
        .video-row.collapsed .title-container .title-wrapper {
            display: flex !important;
        }
        
        .video-details-content {
            display: flex;
            flex-direction: row;
            gap: 15px;

            align-items: flex-start;
        }
        
        .video-details-content .waveform-container {
            flex: 1;
            min-width: 0;
            overflow-x: auto;
            order: 1;
            overflow-y: hidden;
        }
        
        .video-details-content .audio-controls-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            align-items: center;
            justify-items: center;
            flex-shrink: 0;
            order: 2;
        }
        
        .video-details-content .audio-player-hidden {
            order: 0;
            display: none;
        }
        
        .collapse-toggle-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 8px;
        }
        
        .collapse-toggle-btn:hover {
            background: #5568d3;
            transform: scale(1.05);
        }
        
        .collapse-toggle-btn.collapsed {
            background: #4CAF50;
        }
        
        .collapse-toggle-btn.collapsed:hover {
            background: #45a049;
        }
        
        .additional-row td {
            padding: 5px;
        }
        
        .additional-row-content {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            border: 2px solid #333;
            border-radius: 8px;
            background: #e0e0e0;
            height: 100px;
            flex: 1;
            min-width: 0;
            max-width: 1110px;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        .additional-row-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        
        .play-audio-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .play-audio-btn:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .play-audio-btn.playing {
            background: #f44336;
        }
        
        .play-audio-btn.playing:hover {
            background: #d32f2f;
        }
        
        .play-audio-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-controls-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            align-items: center;
            justify-items: center;
        }
        
        .audio-download-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .audio-download-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .audio-download-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-normalize-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .audio-normalize-btn:hover {
            background: #7B1FA2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .audio-normalize-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-player-hidden {
            display: none;
        }
        
        .waveform-container {
            position: relative;
            display: inline-block;
            height: 88px;
            cursor: pointer;
        }
        
        .waveform-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4444;
            cursor: ew-resize;
            z-index: 10;
        }
        
        .waveform-marker.start {
            left: 0;
            background: #4CAF50;
        }
        
        .waveform-marker.end {
            right: 0;
            background: #ff4444;
        }
        
        .waveform-marker::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid currentColor;
        }
        
        .waveform-marker.start::before {
            border-top-color: #4CAF50;
        }
        
        .waveform-marker.end::before {
            border-top-color: #ff4444;
        }
        
        .waveform-marker::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid currentColor;
        }
        
        .waveform-marker.start::after {
            border-bottom-color: #4CAF50;
        }
        
        .waveform-marker.end::after {
            border-bottom-color: #ff4444;
        }
        
        .waveform-playback-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff0000;
            cursor: pointer;
            z-index: 20;
            display: none;
            pointer-events: none;
        }
        
        .waveform-playback-marker::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #ff0000;
        }
        
        .waveform-playback-marker::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid #ff0000;
        }
        
        .waveform-selection {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(76, 175, 80, 0.2);
            pointer-events: none;
            z-index: 5;
        }
        
        .audio-trim-btn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .audio-trim-btn:hover {
            background: #F57C00;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .audio-trim-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-compress-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        
        .audio-compress-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .audio-compress-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .combine-floating-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            z-index: 10000;
            display: none;
            align-items: center;
            gap: 8px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        
        .combine-floating-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.5);
        }
        
        .combine-floating-btn.active {
            display: flex !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        .refresh-all-floating-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .refresh-all-floating-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5);
            background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
        }

        .refresh-all-floating-btn:active {
            transform: translateY(0);
        }

        .refresh-all-floating-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1 style="margin: 0;">üìπ Videos Procesados</h1>
            <div style="display: flex; align-items: center; gap: 10px;">
                <!-- Bot√≥n de login de YouTube (cuando no hay sesi√≥n) -->
                <div id="youtube-login-container" style="display: none; margin-right: 10px;">
                    <button id="youtube-login-btn" onclick="loginYouTube()" 
                            style="background: #FF0000; color: white; border: none; padding: 8px 15px; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.3s; box-shadow: 0 2px 8px rgba(255, 0, 0, 0.3);"
                            title="Iniciar sesi√≥n en YouTube">
                        <span>üî¥</span>
                        <span>Login YouTube</span>
                    </button>
                </div>
                <!-- Informaci√≥n del canal de YouTube -->
                <div id="youtube-channel-info" style="display: none; background: rgba(255, 255, 255, 0.95); padding: 8px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); flex-direction: row; align-items: center; gap: 10px; margin-right: 10px;">
                    <img id="youtube-channel-thumbnail" src="" alt="Channel" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; display: none;">
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <div style="font-size: 12px; font-weight: 600; color: #333;">
                            <span id="youtube-channel-title"></span>
                        </div>
                        <div style="font-size: 10px; color: #666;">
                            <span id="youtube-channel-email"></span>
                        </div>
                    </div>
                    <button id="youtube-logout-btn" onclick="logoutYouTube()" 
                            style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer; margin-left: 5px; transition: all 0.3s;"
                            title="Cerrar sesi√≥n de YouTube">
                        üö™ Salir
                    </button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button id="bulk-upload-pinecone-btn" class="bulk-upload-btn" onclick="bulkUploadToPinecone()" 
                            style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; white-space: nowrap; transition: all 0.3s; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                        <span id="bulk-upload-icon">üìä</span>
                        <span id="bulk-upload-text">Subir todas a Pinecone</span>
                        <span id="bulk-upload-counter" style="margin-left: 8px; font-size: 12px; opacity: 0.9;"></span>
                    </button>
                    <button id="bulk-validate-similarities-btn" class="bulk-validate-btn" onclick="bulkValidateSimilarities()" 
                            style="background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; white-space: nowrap; transition: all 0.3s; box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);">
                        <span id="bulk-validate-icon">üîç</span>
                        <span id="bulk-validate-text">Validar similitudes</span>
                        <span id="bulk-validate-counter" style="margin-left: 8px; font-size: 12px; opacity: 0.9;"></span>
                    </button>
                    <button id="view-similarities-btn" class="view-similarities-btn" onclick="loadSimilaritiesFromFile()" 
                            style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; white-space: nowrap; transition: all 0.3s; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);">
                        <span>üìã</span>
                        <span>Ver similitudes guardadas</span>
                    </button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <a href="process-videos.html" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 20px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 14px; transition: all 0.3s; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                        ‚ûï Procesar video
                    </a>
                    <a href="process-sound.html" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 20px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 14px; transition: all 0.3s; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                        üéµ Procesar audio
                    </a>
                </div>
            </div>
        </div>
        
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Cargando videos...</p>
        </div>
        
        <!-- Modal para resumen de validaci√≥n de similitudes -->
        <div id="similarities-summary-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; overflow-y: auto;">
            <div style="position: relative; max-width: 800px; margin: 50px auto; background: white; border-radius: 12px; padding: 30px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);">
                <button id="close-similarities-modal" style="position: absolute; top: 15px; right: 15px; background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                    ‚úï Cerrar
                </button>
                <h2 style="margin-top: 0; color: #2196F3; font-size: 24px; margin-bottom: 20px;">üîç Resumen de Validaci√≥n de Similitudes</h2>
                <div id="similarities-summary-content">
                    <!-- El contenido se llenar√° din√°micamente -->
                </div>
            </div>
        </div>
        
        <div id="error" class="error-message" style="display: none;"></div>
        
        <div id="controls" class="controls" style="display: none;">
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">
                <div style="flex: 1; min-width: 300px; max-width: 500px;">
                    <input type="text" id="searchFilter" placeholder="üîç Buscar por t√≠tulo, ID de YouTube, nombre de archivo..." 
                           style="width: 100%; padding: 10px 15px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                </div>
                <div class="switch-container">
                    <span class="switch-label">Mostrar miniaturas originales</span>
                    <label class="switch">
                        <input type="checkbox" id="showOriginalThumbnails">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="switch-container">
                    <span class="switch-label">Solo sin miniatura original</span>
                    <label class="switch">
                        <input type="checkbox" id="filterNoOriginalThumbnail">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="switch-container">
                    <span class="switch-label">Solo sin descripci√≥n</span>
                    <label class="switch">
                        <input type="checkbox" id="filterNoDescription">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <div id="stats" class="stats-info"></div>
        </div>
        
        <div id="tableContainer" style="display: none;">
            <div id="videosTable" class="videos-container">
                <div id="videosTableBody" class="videos-body">
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = window.location.origin;
        let WAVEFORM_PIXELS_PER_SECOND = 50; // Valor por defecto; se actualiza desde /api/config
        (async function loadConfig() {
            try {
                const res = await fetch(`${API_BASE}/api/config`);
                if (res.ok) {
                    const data = await res.json();
                    if (typeof data.waveformPixelsPerSecond === 'number' && data.waveformPixelsPerSecond > 0) {
                        WAVEFORM_PIXELS_PER_SECOND = data.waveformPixelsPerSecond;
                    }
                }
            } catch (e) {
                console.warn('No se pudo cargar config (waveformPixelsPerSecond):', e.message);
            }
        })();
        let allVideos = []; // Almacenar todos los videos cargados
        let selectedVideos = []; // Almacenar el orden de selecci√≥n de videos (array de √≠ndices)
        
        // Map para almacenar conexiones SSE activas: generationId -> EventSource
        const activeSSEConnections = new Map();
        
        // Map para almacenar elementos de progreso: generationId -> HTMLElement
        const progressElements = new Map();
        
        // Map para almacenar botones de generaci√≥n: generationId -> { button, fileName }
        const generationButtons = new Map();
        
        // Map para almacenar botones de short: shortId -> { button, fileName }
        const shortButtons = new Map();
        
        /**
         * Crea el contenedor flotante de progreso si no existe
         */
        function ensureProgressContainer() {
            let container = document.getElementById('video-generation-progress-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'video-generation-progress-container';
                document.body.appendChild(container);
            }
            return container;
        }
        
        /**
         * Crea un elemento de progreso para una generaci√≥n
         */
        function createProgressElement(type, id, title, fileName = null) {
            // type: 'generation', 'upload', 'trim', 'download'
            const container = ensureProgressContainer();
            
            const item = document.createElement('div');
            item.className = 'video-progress-item';
            item.dataset.type = type;
            item.dataset.id = id;
            if (fileName) {
                item.dataset.fileName = fileName;
            }
            
            // Agregar cursor pointer para indicar que es clickeable
            item.style.cursor = 'pointer';
            item.title = 'Click para ver la llamada en la tabla';
            
            // T√≠tulos por tipo
            const typeTitles = {
                'generation': 'Generando video...',
                'upload': 'Subiendo a YouTube...',
                'trim': 'Recortando audio...',
                'download': 'Descargando audio...'
            };
            
            const defaultTitle = typeTitles[type] || 'Procesando...';
            
            item.innerHTML = `
                <div class="video-progress-title">${escapeHtml(title || defaultTitle)}</div>
                <div class="video-progress-bar-container">
                    <div class="video-progress-bar" style="width: 0%"></div>
                </div>
                <div class="video-progress-text">
                    <span class="video-progress-percent">0%</span>
                    <span class="video-progress-frames"></span>
                </div>
                <div class="video-progress-status">Iniciando...</div>
                <button class="progress-close-btn" style="display: none;">‚úï</button>
            `;
            
            // Agregar evento click para desplazarse a la fila
            if (fileName) {
                item.addEventListener('click', () => {
                    scrollToVideoRow(fileName);
                });
            }
            
            // Bot√≥n cerrar
            const closeBtn = item.querySelector('.progress-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeProgressElement(type, id);
                });
            }
            
            container.appendChild(item);
            const key = `${type}_${id}`;
            progressElements.set(key, item);
            return item;
        }
        
        /**
         * Desplaza la p√°gina hasta la fila del video especificado
         */
        function scrollToVideoRow(fileName) {
            if (!fileName) return;
            
            // Buscar el elemento titleDiv que tiene el data-file-name
            const titleDivs = document.querySelectorAll('[data-file-name]');
            let targetRow = null;
            
            for (const titleDiv of titleDivs) {
                if (titleDiv.getAttribute('data-file-name') === fileName) {
                    // Encontrar la fila padre (tr)
                    targetRow = titleDiv.closest('tr');
                    if (targetRow) break;
                }
            }
            
            if (targetRow) {
                // Hacer scroll hasta la fila con un offset para que no quede pegado arriba
                const offset = 100; // Offset en p√≠xeles desde arriba
                const elementPosition = targetRow.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - offset;
                
                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
                
                // Resaltar la fila brevemente
                const originalBg = targetRow.style.backgroundColor;
                targetRow.style.backgroundColor = '#fff3cd';
                targetRow.style.transition = 'background-color 0.3s';
                
                setTimeout(() => {
                    targetRow.style.backgroundColor = originalBg || '';
                    setTimeout(() => {
                        targetRow.style.transition = '';
                    }, 300);
                }, 2000);
            } else {
                console.warn(`No se encontr√≥ la fila para el video: ${fileName}`);
            }
        }
        
        /**
         * Actualiza el elemento de progreso
         * @param {string} type - Tipo de progreso: 'generation', 'upload', 'trim', 'download'
         * @param {string} id - ID del proceso
         * @param {object} progressData - Datos de progreso
         */
        function updateProgressElement(type, id, progressData) {
            const key = `${type}_${id}`;
            const element = progressElements.get(key);
            if (!element) return;
            
            const percent = progressData.percent || 0;
            const status = progressData.status || 'processing';
            
            // Actualizar barra de progreso
            const bar = element.querySelector('.video-progress-bar');
            if (bar) {
                bar.style.width = `${percent}%`;
            }
            
            // Actualizar porcentaje
            const percentSpan = element.querySelector('.video-progress-percent');
            if (percentSpan) {
                percentSpan.textContent = `${percent}%`;
            }
            
            // Actualizar frames/info adicional (solo para generaci√≥n y short)
            const framesSpan = element.querySelector('.video-progress-frames');
            if (framesSpan) {
                if (type === 'generation' || type === 'short') {
                    const frames = progressData.frames || 0;
                    const totalFrames = progressData.totalFrames || 0;
                    framesSpan.textContent = `${frames}/${totalFrames}`;
                } else if (type === 'upload') {
                    const bytesUploaded = progressData.bytesUploaded || 0;
                    const totalBytes = progressData.totalBytes || 0;
                    const mbUploaded = (bytesUploaded / 1024 / 1024).toFixed(2);
                    const mbTotal = (totalBytes / 1024 / 1024).toFixed(2);
                    framesSpan.textContent = `${mbUploaded}MB / ${mbTotal}MB`;
                } else {
                    framesSpan.textContent = '';
                }
            }
            
            // Actualizar estado
            const statusDiv = element.querySelector('.video-progress-status');
            if (statusDiv) {
                if (status === 'completed') {
                    statusDiv.textContent = '‚úÖ Completado';
                    element.classList.add('completed');
                } else if (status === 'error') {
                    statusDiv.textContent = `‚ùå Error: ${progressData.error || 'Error desconocido'}`;
                    element.classList.add('error');
                } else if (status === 'cancelled') {
                    statusDiv.textContent = '‚èπÔ∏è Cancelado';
                    element.classList.add('cancelled');
                } else if ((type === 'generation' || type === 'short') && progressData.fps > 0) {
                    statusDiv.textContent = `Procesando... ${progressData.fps.toFixed(1)} FPS`;
                } else {
                    const messages = {
                        'upload': 'Subiendo...',
                        'trim': 'Recortando...',
                        'download': 'Descargando...',
                        'generation': 'Procesando...',
                        'short': 'Generando Short...'
                    };
                    statusDiv.textContent = progressData.message || messages[type] || 'Procesando...';
                }
            }
            
            // Actualizar bot√≥n de generaci√≥n si existe (solo para type === 'generation')
            if (type === 'generation') {
                const buttonInfo = generationButtons.get(id);
                if (buttonInfo && buttonInfo.button) {
                    const button = buttonInfo.button;
                    const textSpan = button.querySelector('.text');
                    if (textSpan) {
                        if (status === 'completed') {
                            textSpan.textContent = 'Generar Video';
                            button.disabled = false;
                        } else if (status === 'error') {
                            textSpan.textContent = 'Generar Video';
                            button.disabled = false;
                        } else {
                            // Mostrar porcentaje en el texto
                            textSpan.textContent = `Generar Video (${percent}%)`;
                            button.disabled = true;
                        }
                    }
                }
            }
            
            // Actualizar bot√≥n de short si existe (solo para type === 'short')
            if (type === 'short') {
                const buttonInfo = shortButtons.get(id);
                if (buttonInfo && buttonInfo.button) {
                    const button = buttonInfo.button;
                    const textSpan = button.querySelector('.text');
                    if (textSpan) {
                        if (status === 'completed') {
                            textSpan.textContent = 'Generar Short';
                            button.disabled = false;
                        } else if (status === 'error') {
                            textSpan.textContent = 'Generar Short';
                            button.disabled = false;
                        } else {
                            // Mostrar porcentaje en el texto
                            textSpan.textContent = `Generar Short (${percent}%)`;
                            button.disabled = true;
                        }
                    }
                }
            }
            
            // Actualizar bot√≥n de upload si existe
            if (type === 'upload') {
                const fileName = element.dataset.fileName;
                if (fileName) {
                    const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                    if (videoIndex >= 0) {
                        const video = allVideos[videoIndex];
                        const row = document.querySelector(`[data-file-name="${fileName}"]`)?.closest('tr');
                        if (row) {
                            const uploadBtn = row.querySelector('.upload-btn');
                            if (uploadBtn) {
                                if (status === 'completed') {
                                    uploadBtn.textContent = 'Subir a YouTube';
                                    uploadBtn.disabled = false;
                                } else if (status === 'error') {
                                    uploadBtn.textContent = 'Subir a YouTube';
                                    uploadBtn.disabled = false;
                                } else {
                                    uploadBtn.textContent = `Subiendo... (${percent}%)`;
                                    uploadBtn.disabled = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        /**
         * Elimina un elemento de progreso
         * @param {string} type - Tipo de progreso: 'generation', 'upload', 'trim', 'download'
         * @param {string} id - ID del proceso
         */
        function removeProgressElement(type, id) {
            const key = `${type}_${id}`;
            const element = progressElements.get(key);
            if (element) {
                element.remove();
                progressElements.delete(key);
            }
            
            // Restaurar bot√≥n de generaci√≥n (solo para type === 'generation')
            if (type === 'generation') {
                const buttonInfo = generationButtons.get(id);
                if (buttonInfo && buttonInfo.button) {
                    const button = buttonInfo.button;
                    const textSpan = button.querySelector('.text');
                    if (textSpan) {
                        textSpan.textContent = 'Generar Video';
                    }
                    button.disabled = false;
                    generationButtons.delete(id);
                }
            }
            
            // Cerrar conexi√≥n SSE si existe
            const eventSource = activeSSEConnections.get(key);
            if (eventSource) {
                eventSource.close();
                activeSSEConnections.delete(key);
            }
            
            // Limpiar de localStorage seg√∫n el tipo
            const storageKeys = {
                'generation': 'videoGenerations',
                'upload': 'youtubeUploads',
                'trim': 'audioTrims',
                'download': 'audioDownloads'
            };
            
            const storageKey = storageKeys[type];
            if (storageKey) {
                const stored = JSON.parse(localStorage.getItem(storageKey) || '[]');
                const filtered = stored.filter(storedId => storedId !== id);
                localStorage.setItem(storageKey, JSON.stringify(filtered));
            }
        }


        async function refreshAllVideos() {
            const refreshBtn = document.getElementById('refresh-all-floating-btn');
            if (refreshBtn) {
                refreshBtn.disabled = true;
                const originalText = refreshBtn.innerHTML;
                refreshBtn.innerHTML = '‚è≥ Actualizando...';
                
                try {
                    await loadVideos();
                    
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 80px; right: 30px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001;';
                    successMsg.textContent = '‚úÖ Videos actualizados';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                } catch (error) {
                    console.error('Error al actualizar videos:', error);
                    alert(`Error al actualizar videos: ${error.message}`);
                } finally {
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalText;
                }
            } else {
                await loadVideos();
            }
        }
        
        /**
         * Conecta a un stream SSE para recibir progreso
         * @param {string} type - Tipo de progreso: 'generation', 'upload', 'trim', 'download'
         * @param {string} id - ID del proceso
         */
        function connectToProgressSSE(type, id) {
            const key = `${type}_${id}`;
            
            // Si ya hay una conexi√≥n activa, no crear otra
            if (activeSSEConnections.has(key)) {
                return;
            }
            
            // Endpoints SSE por tipo
            const endpoints = {
                'generation': `/api/video/generation-progress?generationId=`,
                'upload': `/api/video/youtube/upload-progress-sse?uploadId=`,
                'trim': `/api/video/audio/trim-progress?trimId=`,
                'download': `/api/video/audio/download-progress?downloadId=`,
                'compress': `/api/video/audio/compression-progress?compressionId=`,
                'short': `/api/video/short-progress?shortId=`
            };
            
            const endpoint = endpoints[type];
            if (!endpoint) {
                console.error(`Tipo de progreso no v√°lido: ${type}`);
                return;
            }
            
            const eventSource = new EventSource(`${API_BASE}${endpoint}${encodeURIComponent(id)}`);
            
            eventSource.onmessage = (event) => {
                try {
                    const progressData = JSON.parse(event.data);
                    updateProgressElement(type, id, progressData);
                    
                    // Si est√° completado, actualizar la fila del video y remover despu√©s de 5 segundos
                    if (progressData.status === 'completed') {
                        // Para generaci√≥n, buscar el video por outputPath
                        if (type === 'generation') {
                            const outputPath = progressData.outputPath;
                            if (outputPath) {
                                // Extraer fileName del outputPath
                                const fileNameMatch = outputPath.match(/([^/\\]+)\.mp4$/);
                                if (fileNameMatch) {
                                    const fileName = fileNameMatch[1];
                                    // Buscar el √≠ndice del video en allVideos
                                    const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                                    if (videoIndex >= 0) {
                                        // Actualizar la fila del video despu√©s de un breve delay
                                        setTimeout(() => {
                                            updateSingleVideoRow(videoIndex, fileName);
                                        }, 1000);
                                    }
                                }
                            }
                        } else if (type === 'short') {
                            // Para short, buscar el video por outputPath
                            const outputPath = progressData.outputPath;
                            if (outputPath) {
                                // Extraer fileName del outputPath (formato: fileName_short.mp4)
                                const fileNameMatch = outputPath.match(/([^/\\]+)_short\.mp4$/);
                                if (fileNameMatch) {
                                    const fileName = fileNameMatch[1];
                                    const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                                    if (videoIndex >= 0) {
                                        setTimeout(() => {
                                            updateSingleVideoRow(videoIndex, fileName);
                                        }, 1000);
                                    }
                                }
                            }
                        } else if (type === 'upload' || type === 'trim' || type === 'download' || type === 'compress') {
                            // Para upload, trim y download, buscar por fileName en el elemento
                            const element = progressElements.get(key);
                            if (element) {
                                const fileName = element.dataset.fileName;
                                if (fileName) {
                                    const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                                    if (videoIndex >= 0) {
                                        const video = allVideos[videoIndex];
                                        
                                        // Para trim y compress, recargar el audio y actualizar waveform
                                        if (type === 'trim' || type === 'compress') {
                                            // Buscar el contenedor de audio del video
                                            const row = document.querySelector(`[data-file-name="${fileName}"]`)?.closest('tr');
                                            if (row) {
                                                const audioElement = row.querySelector(`#audio-player-${videoIndex}`);
                                                const playBtn = row.querySelector(`#play-btn-${videoIndex}`);
                                                const playbackMarker = row.querySelector(`#playback-marker-${videoIndex}`);
                                                
                                                if (audioElement) {
                                                    // Recargar duraci√≥n del audio
                                                    setTimeout(async () => {
                                                        try {
                                                            // Usar timestamp √∫nico para forzar recarga del navegador
                                                            const timestamp = Date.now();
                                                            const audioUrl = `${API_BASE}/api/video/audio/${encodeURIComponent(fileName)}.mp3?v=${timestamp}`;
                                                            const wasPlaying = !audioElement.paused;
                                                            
                                                            if (wasPlaying) {
                                                                audioElement.pause();
                                                            }
                                                            
                                                            // Limpiar completamente el elemento de audio para forzar recarga
                                                            audioElement.removeAttribute('src');
                                                            audioElement.load();
                                                            
                                                            // Esperar un momento para que el navegador procese la limpieza
                                                            await new Promise(resolve => setTimeout(resolve, 100));
                                                            
                                                            // Asignar nuevo src con par√°metro de cach√©
                                                            audioElement.src = audioUrl;
                                                            
                                                            // Forzar recarga del nuevo audio
                                                            audioElement.load();
                                                            
                                                            // Esperar a que el audio est√© listo antes de reproducir
                                                            if (wasPlaying) {
                                                                const canPlayHandler = () => {
                                                                    audioElement.removeEventListener('canplay', canPlayHandler);
                                                                    audioElement.currentTime = 0; // Reiniciar desde el inicio
                                                                    audioElement.play().catch(err => {
                                                                        console.error('Error al reproducir audio recortado:', err);
                                                                    });
                                                                };
                                                                audioElement.addEventListener('canplay', canPlayHandler, { once: true });
                                                                
                                                                // Timeout de seguridad si el evento no se dispara
                                                                setTimeout(() => {
                                                                    if (!audioElement.paused) return; // Ya est√° reproduciendo
                                                                    audioElement.currentTime = 0;
                                                                    audioElement.play().catch(err => {
                                                                        console.error('Error al reproducir audio recortado (timeout):', err);
                                                                    });
                                                                }, 2000);
                                                            } else {
                                                                if (playBtn) {
                                                                    playBtn.innerHTML = '‚ñ∂Ô∏è';
                                                                    playBtn.title = 'Reproducir';
                                                                    playBtn.classList.remove('playing');
                                                                }
                                                            }
                                                            
                                                            if (playbackMarker) {
                                                                playbackMarker.style.left = '0%';
                                                            }
                                                            
                                                            // Actualizar waveform si existe la funci√≥n
                                                            if (typeof updateWaveform === 'function') {
                                                                await updateWaveform();
                                                            }
                                                        } catch (err) {
                                                            console.error('Error al recargar audio despu√©s de trim:', err);
                                                        }
                                                    }, 500);
                                                }
                                            }
                                        }
                                        
                                        // Para download, recargar el audio
                                        if (type === 'download') {
                                            const row = document.querySelector(`[data-file-name="${fileName}"]`)?.closest('tr');
                                            if (row) {
                                                const audioElement = row.querySelector(`#audio-player-${videoIndex}`);
                                                const playBtn = row.querySelector(`#play-btn-${videoIndex}`);
                                                
                                                if (audioElement) {
                                                    setTimeout(async () => {
                                                        try {
                                                            // Usar timestamp √∫nico para forzar recarga del navegador
                                                            const timestamp = Date.now();
                                                            const audioUrl = `${API_BASE}/api/video/audio/${encodeURIComponent(fileName)}.mp3?v=${timestamp}`;
                                                            
                                                            // Limpiar completamente el elemento de audio para forzar recarga
                                                            audioElement.removeAttribute('src');
                                                            audioElement.load();
                                                            
                                                            // Esperar un momento para que el navegador procese la limpieza
                                                            await new Promise(resolve => setTimeout(resolve, 100));
                                                            
                                                            // Asignar nuevo src con par√°metro de cach√©
                                                            audioElement.src = audioUrl;
                                                            
                                                            // Forzar recarga del nuevo audio
                                                            audioElement.load();
                                                            
                                                            if (playBtn) {
                                                                playBtn.innerHTML = '‚ñ∂Ô∏è';
                                                                playBtn.title = 'Reproducir';
                                                                playBtn.classList.remove('playing');
                                                            }
                                                            
                                                            // Actualizar waveform si existe la funci√≥n
                                                            if (typeof updateWaveform === 'function') {
                                                                await updateWaveform();
                                                            }
                                                        } catch (err) {
                                                            console.error('Error al recargar audio despu√©s de download:', err);
                                                        }
                                                    }, 500);
                                                }
                                            }
                                        }
                                        
                                        setTimeout(() => {
                                            updateSingleVideoRow(videoIndex, fileName);
                                        }, 1000);
                                    }
                                }
                            }
                        }
                        
                        setTimeout(() => {
                            removeProgressElement('generation', generationId);
                        }, 5000);
                    } else if (progressData.status === 'error') {
                        setTimeout(() => {
                            removeProgressElement('generation', generationId);
                        }, 10000); // 10 segundos para errores
                    }
                } catch (error) {
                    console.error('Error al parsear progreso SSE:', error);
                }
            };
            
            eventSource.onerror = (error) => {
                console.error(`Error en SSE para ${type} ${id}:`, error);
                // No cerrar la conexi√≥n autom√°ticamente, puede ser temporal
            };
            
            activeSSEConnections.set(key, eventSource);
        }
        
        /**
         * Guarda generationId en localStorage
         */
        function saveGenerationId(generationId) {
            const stored = JSON.parse(localStorage.getItem('videoGenerations') || '[]');
            if (!stored.includes(generationId)) {
                stored.push(generationId);
                localStorage.setItem('videoGenerations', JSON.stringify(stored));
            }
        }
        
        /**
         * Guarda shortId en localStorage
         */
        function saveShortId(shortId) {
            const stored = JSON.parse(localStorage.getItem('videoShorts') || '[]');
            if (!stored.includes(shortId)) {
                stored.push(shortId);
                localStorage.setItem('videoShorts', JSON.stringify(stored));
            }
        }
        
        /**
         * Reconecta a todas las generaciones guardadas en localStorage
         */
        async function reconnectToGenerations() {
            const stored = JSON.parse(localStorage.getItem('videoGenerations') || '[]');
            
            if (stored.length === 0) {
                // Si no hay generaciones guardadas, consultar el endpoint de respaldo
                try {
                    const response = await fetch(`${API_BASE}/api/video/active-generations`);
                    const data = await response.json();
                    
                    if (data.success && data.activeGenerations) {
                        data.activeGenerations.forEach(gen => {
                            if (!progressElements.has(gen.generationId)) {
                                createProgressElement('generation', gen.generationId, gen.videoTitle);
                                updateProgressElement('generation', gen.generationId, gen);
                                connectToProgressSSE('generation', gen.generationId);
                                saveGenerationId(gen.generationId);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener generaciones activas:', error);
                }
                return;
            }
            
            // Reconectar a cada generaci√≥n guardada
            for (const generationId of stored) {
                try {
                    // Verificar si la generaci√≥n sigue activa
                    const response = await fetch(`${API_BASE}/api/video/active-generations`);
                    const data = await response.json();
                    
                    const isActive = data.success && data.activeGenerations.some(gen => gen.generationId === generationId);
                    
                    if (isActive) {
                        // Crear elemento y conectar
                        const activeGen = data.activeGenerations.find(gen => gen.generationId === generationId);
                    if (activeGen && !progressElements.has(generationId)) {
                        // Extraer fileName del outputPath si est√° disponible
                        let fileName = null;
                        if (activeGen.outputPath) {
                            const fileNameMatch = activeGen.outputPath.match(/([^/\\]+)\.mp4$/);
                            if (fileNameMatch) {
                                fileName = fileNameMatch[1];
                            }
                        }
                        
                        // Buscar el bot√≥n de generaci√≥n para este fileName
                        if (fileName) {
                            const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                            if (videoIndex >= 0) {
                                // Buscar el bot√≥n en la tabla
                                const titleDivs = document.querySelectorAll(`[data-file-name="${fileName}"]`);
                                for (const titleDiv of titleDivs) {
                                    const row = titleDiv.closest('tr');
                                    if (row) {
                                        const button = row.querySelector('.generate-video-btn');
                                        if (button) {
                                            generationButtons.set(generationId, {
                                                button: button,
                                                fileName: fileName
                                            });
                                            // Actualizar el bot√≥n con el progreso actual
                                            const textSpan = button.querySelector('.text');
                                            if (textSpan) {
                                                const percent = activeGen.percent || 0;
                                                if (activeGen.status === 'completed' || activeGen.status === 'error') {
                                                    textSpan.textContent = 'Generar Video';
                                                    button.disabled = false;
                                                } else {
                                                    textSpan.textContent = `Generar Video (${percent}%)`;
                                                    button.disabled = true;
                                                }
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        createProgressElement('generation', generationId, activeGen.videoTitle, fileName);
                        updateProgressElement('generation', generationId, activeGen);
                        connectToProgressSSE('generation', generationId);
                    }
                    } else {
                        // Generaci√≥n completada o no existe, limpiar
                        localStorage.setItem('videoGenerations', JSON.stringify(stored.filter(id => id !== generationId)));
                    }
                } catch (error) {
                    console.error(`Error al reconectar generaci√≥n ${generationId}:`, error);
                }
            }
        }
        
        /**
         * Reconecta a todas las subidas activas guardadas en localStorage
         */
        async function reconnectToUploads() {
            const stored = JSON.parse(localStorage.getItem('youtubeUploads') || '[]');
            
            if (stored.length === 0) {
                try {
                    const response = await fetch(`${API_BASE}/api/video/youtube/active-uploads`);
                    const data = await response.json();
                    
                    if (data.success && data.activeUploads) {
                        data.activeUploads.forEach(upload => {
                            const key = `upload_${upload.uploadId}`;
                            if (!progressElements.has(key)) {
                                createProgressElement('upload', upload.uploadId, upload.videoTitle || 'Subiendo...');
                                updateProgressElement('upload', upload.uploadId, upload);
                                connectToProgressSSE('upload', upload.uploadId);
                                
                                const stored = JSON.parse(localStorage.getItem('youtubeUploads') || '[]');
                                if (!stored.includes(upload.uploadId)) {
                                    stored.push(upload.uploadId);
                                    localStorage.setItem('youtubeUploads', JSON.stringify(stored));
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener subidas activas:', error);
                }
                return;
            }
            
            // Reconectar directamente - el SSE enviar√° el estado inicial
            for (const uploadId of stored) {
                const key = `upload_${uploadId}`;
                if (!progressElements.has(key)) {
                    createProgressElement('upload', uploadId, 'Subiendo a YouTube...', null);
                    connectToProgressSSE('upload', uploadId);
                }
            }
        }
        
        /**
         * Reconecta a todos los recortes activos guardados en localStorage
         */
        async function reconnectToTrims() {
            const stored = JSON.parse(localStorage.getItem('audioTrims') || '[]');
            
            if (stored.length === 0) {
                try {
                    const response = await fetch(`${API_BASE}/api/video/audio/active-trims`);
                    const data = await response.json();
                    
                    if (data.success && data.activeTrims) {
                        data.activeTrims.forEach(trim => {
                            const key = `trim_${trim.trimId}`;
                            if (!progressElements.has(key)) {
                                const title = `Recortando audio: ${trim.fileName || 'Audio'}`;
                                createProgressElement('trim', trim.trimId, title, trim.fileName);
                                updateProgressElement('trim', trim.trimId, trim);
                                connectToProgressSSE('trim', trim.trimId);
                                
                                const stored = JSON.parse(localStorage.getItem('audioTrims') || '[]');
                                if (!stored.includes(trim.trimId)) {
                                    stored.push(trim.trimId);
                                    localStorage.setItem('audioTrims', JSON.stringify(stored));
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener recortes activos:', error);
                }
                return;
            }
            
            // Reconectar directamente - el SSE enviar√° el estado inicial
            for (const trimId of stored) {
                const key = `trim_${trimId}`;
                if (!progressElements.has(key)) {
                    createProgressElement('trim', trimId, 'Recortando audio...', null);
                    connectToProgressSSE('trim', trimId);
                }
            }
        }
        
        /**
         * Reconecta a todas las descargas activas guardadas en localStorage
         */
        async function reconnectToDownloads() {
            const stored = JSON.parse(localStorage.getItem('audioDownloads') || '[]');
            
            if (stored.length === 0) {
                try {
                    const response = await fetch(`${API_BASE}/api/video/audio/active-downloads`);
                    const data = await response.json();
                    
                    if (data.success && data.activeDownloads) {
                        data.activeDownloads.forEach(download => {
                            const key = `download_${download.downloadId}`;
                            if (!progressElements.has(key)) {
                                const title = `Descargando audio: ${download.fileName || 'Audio'}`;
                                createProgressElement('download', download.downloadId, title, download.fileName);
                                updateProgressElement('download', download.downloadId, download);
                                connectToProgressSSE('download', download.downloadId);
                                
                                const stored = JSON.parse(localStorage.getItem('audioDownloads') || '[]');
                                if (!stored.includes(download.downloadId)) {
                                    stored.push(download.downloadId);
                                    localStorage.setItem('audioDownloads', JSON.stringify(stored));
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener descargas activas:', error);
                }
                return;
            }
            
            // Reconectar directamente - el SSE enviar√° el estado inicial
            for (const downloadId of stored) {
                const key = `download_${downloadId}`;
                if (!progressElements.has(key)) {
                    createProgressElement('download', downloadId, 'Descargando audio...', null);
                    connectToProgressSSE('download', downloadId);
                }
            }
        }
        
        /**
         * Reconecta a todas las compresiones activas guardadas en localStorage
         */
        async function reconnectToCompressions() {
            const stored = JSON.parse(localStorage.getItem('audioCompressions') || '[]');
            
            if (stored.length === 0) {
                try {
                    const response = await fetch(`${API_BASE}/api/video/audio/active-compressions`);
                    const data = await response.json();
                    
                    if (data.success && data.compressions) {
                        data.compressions.forEach(compression => {
                            const key = `compress_${compression.compressionId}`;
                            if (!progressElements.has(key)) {
                                const title = `Comprimiendo audio: ${compression.fileName || 'Audio'}`;
                                createProgressElement('compress', compression.compressionId, title, compression.fileName);
                                updateProgressElement('compress', compression.compressionId, compression);
                                connectToProgressSSE('compress', compression.compressionId);
                                
                                const stored = JSON.parse(localStorage.getItem('audioCompressions') || '[]');
                                if (!stored.includes(compression.compressionId)) {
                                    stored.push(compression.compressionId);
                                    localStorage.setItem('audioCompressions', JSON.stringify(stored));
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener compresiones activas:', error);
                }
                return;
            }
            
            // Reconectar directamente - el SSE enviar√° el estado inicial
            for (const compressionId of stored) {
                const key = `compress_${compressionId}`;
                if (!progressElements.has(key)) {
                    createProgressElement('compress', compressionId, 'Comprimiendo audio...', null);
                    connectToProgressSSE('compress', compressionId);
                }
            }
        }
        
        /**
         * Reconecta a todos los procesos activos al cargar la p√°gina
         */
        /**
         * Reconecta a todos los shorts guardados en localStorage
         */
        async function reconnectToShorts() {
            const stored = JSON.parse(localStorage.getItem('videoShorts') || '[]');
            
            if (stored.length === 0) {
                // Si no hay shorts guardados, consultar el endpoint de respaldo
                try {
                    const response = await fetch(`${API_BASE}/api/video/active-shorts`);
                    const data = await response.json();
                    
                    if (data.success && data.activeShorts) {
                        data.activeShorts.forEach(short => {
                            if (!progressElements.has(`short_${short.shortId}`)) {
                                // Extraer fileName del outputPath si est√° disponible
                                let fileName = null;
                                if (short.outputPath) {
                                    const fileNameMatch = short.outputPath.match(/([^/\\]+)_short\.mp4$/);
                                    if (fileNameMatch) {
                                        fileName = fileNameMatch[1];
                                    }
                                }
                                createProgressElement('short', short.shortId, short.videoTitle, fileName);
                                updateProgressElement('short', short.shortId, short);
                                connectToProgressSSE('short', short.shortId);
                                saveShortId(short.shortId);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error al obtener shorts activos:', error);
                }
                return;
            }
            
            // Reconectar a cada short guardado
            for (const shortId of stored) {
                try {
                    // Verificar si el short sigue activo
                    const response = await fetch(`${API_BASE}/api/video/active-shorts`);
                    const data = await response.json();
                    
                    const isActive = data.success && data.activeShorts.some(s => s.shortId === shortId);
                    
                    if (isActive) {
                        // Crear elemento y conectar
                        const activeShort = data.activeShorts.find(s => s.shortId === shortId);
                        if (activeShort && !progressElements.has(`short_${shortId}`)) {
                            // Extraer fileName del outputPath si est√° disponible
                            let fileName = null;
                            if (activeShort.outputPath) {
                                const fileNameMatch = activeShort.outputPath.match(/([^/\\]+)_short\.mp4$/);
                                if (fileNameMatch) {
                                    fileName = fileNameMatch[1];
                                }
                            }
                            
                            // Buscar el bot√≥n de short para este fileName
                            if (fileName) {
                                const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
                                if (videoIndex >= 0) {
                                    // Buscar el bot√≥n en la tabla
                                    const titleDivs = document.querySelectorAll(`[data-file-name="${fileName}"]`);
                                    for (const titleDiv of titleDivs) {
                                        const row = titleDiv.closest('tr');
                                        if (row) {
                                            const button = row.querySelector('.generate-short-btn');
                                            if (button) {
                                                shortButtons.set(shortId, {
                                                    button: button,
                                                    fileName: fileName
                                                });
                                                // Actualizar el bot√≥n con el progreso actual
                                                const textSpan = button.querySelector('.text');
                                                if (textSpan) {
                                                    const percent = activeShort.percent || 0;
                                                    if (activeShort.status === 'completed' || activeShort.status === 'error') {
                                                        textSpan.textContent = 'Generar Short';
                                                        button.disabled = false;
                                                    } else {
                                                        textSpan.textContent = `Generar Short (${percent}%)`;
                                                        button.disabled = true;
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            createProgressElement('short', shortId, activeShort.videoTitle, fileName);
                            updateProgressElement('short', shortId, activeShort);
                            connectToProgressSSE('short', shortId);
                        }
                    } else {
                        // Short completado o no existe, limpiar
                        localStorage.setItem('videoShorts', JSON.stringify(stored.filter(id => id !== shortId)));
                    }
                } catch (error) {
                    console.error(`Error al reconectar short ${shortId}:`, error);
                }
            }
        }
        
        async function reconnectToAllProgress() {
            await Promise.all([
                reconnectToGenerations(),
                reconnectToUploads(),
                reconnectToTrims(),
                reconnectToDownloads(),
                reconnectToCompressions(),
                reconnectToShorts()
            ]);
        }
        
        async function loadVideos() {
            try {
                const response = await fetch(`${API_BASE}/api/video/list`);
                const data = await response.json();
                
                document.getElementById('loading').style.display = 'none';
                
                if (!response.ok) {
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error: ${data.error || data.message || 'Error desconocido'}`;
                    return;
                }
                
                if (data.success && data.videos) {
                    allVideos = data.videos; // Guardar todos los videos
                    
                    
                    
                    console.log(`[Frontend] Total de videos recibidos: ${allVideos.length}`);
                    
                    applyFilters(); // Aplicar filtros iniciales
                    updateStats();
                    document.getElementById('controls').style.display = 'flex';
                    
                    // Actualizar contador del bot√≥n de subida masiva
                    updateBulkUploadCounter();
                    
                    // Cargar preferencia de mostrar miniaturas originales (por defecto false/oculto)
                    const showOriginal = localStorage.getItem('showOriginalThumbnails') === 'true';
                    document.getElementById('showOriginalThumbnails').checked = showOriginal;
                    toggleOriginalThumbnails(showOriginal);
                } else {
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = 'No se pudieron cargar los videos';
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error de conexi√≥n: ${error.message}`;
            }
        }
        
        /**
         * Maneja la selecci√≥n de videos y guarda el orden de selecci√≥n
         * @param {number} videoIndex - √çndice del video en el array allVideos
         * @param {boolean} isChecked - Si el checkbox est√° marcado o no
         */
        function handleVideoSelection(videoIndex, isChecked) {
            if (isChecked) {
                // Si no est√° ya seleccionado, agregarlo al final (mantener orden de selecci√≥n)
                if (!selectedVideos.includes(videoIndex)) {
                    selectedVideos.push(videoIndex);
                    console.log(`Video ${videoIndex} seleccionado. Orden actual:`, selectedVideos);
                }
            } else {
                // Remover de la selecci√≥n
                const index = selectedVideos.indexOf(videoIndex);
                if (index > -1) {
                    selectedVideos.splice(index, 1);
                    console.log(`Video ${videoIndex} deseleccionado. Orden actual:`, selectedVideos);
                }
            }
            
            // Mostrar/ocultar bot√≥n flotante de combinar
            updateCombineButton();
        }
        
        /**
         * Actualiza la visibilidad del bot√≥n flotante de combinar
         */
        function updateCombineButton() {
            const combineBtn = document.getElementById('combine-floating-btn');
            if (combineBtn) {
                if (selectedVideos.length > 1) {
                    combineBtn.classList.add('active');
                    combineBtn.textContent = `üîó Combinar (${selectedVideos.length})`;
                    console.log(`[Frontend] Bot√≥n combinar activado. Seleccionados: ${selectedVideos.length}`);
                } else {
                    combineBtn.classList.remove('active');
                    console.log(`[Frontend] Bot√≥n combinar desactivado. Seleccionados: ${selectedVideos.length}`);
                }
            } else {
                console.warn('[Frontend] Bot√≥n combinar no encontrado en el DOM');
            }
        }
        
        /**
         * Alterna el estado de colapso de los detalles del video
         * @param {HTMLElement} button - Bot√≥n que activ√≥ el toggle
         */
        function toggleRowCollapse(button) {
            const containerId = button.getAttribute('data-container-id');
            if (!containerId) {
                console.error('No se encontr√≥ el ID del contenedor');
                return;
            }
            
            const detailsContainer = document.getElementById(containerId);
            if (!detailsContainer) {
                console.error(`No se encontr√≥ el contenedor con ID: ${containerId}`);
                return;
            }
            
            // Encontrar el wrapper que contiene tanto el video-row como el details-container
            const rowWrapper = detailsContainer.parentElement;
            if (!rowWrapper || !rowWrapper.classList.contains('video-row-wrapper')) {
                console.error('No se encontr√≥ el wrapper de la fila');
                return;
            }
            
            // Encontrar el video-row dentro del wrapper
            const videoRow = rowWrapper.querySelector('.video-row');
            
            const isCollapsed = detailsContainer.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expandir
                detailsContainer.classList.remove('collapsed');
                if (videoRow) {
                    videoRow.classList.remove('collapsed');
                }
                button.classList.remove('collapsed');
                button.innerHTML = '‚ñ≤ Colapsar';
            } else {
                // Colapsar
                detailsContainer.classList.add('collapsed');
                if (videoRow) {
                    videoRow.classList.add('collapsed');
                }
                button.classList.add('collapsed');
                button.innerHTML = '‚ñº Expandir';
            }
        }
        
        function displayVideos(videos, targetBody = null, startIndex = 0) {
            const body = targetBody || document.getElementById('videosTableBody');
            if (!targetBody) {
                body.innerHTML = '';
            }
            
            console.log(`[Frontend] displayVideos llamado con ${videos.length} videos`);
            
            // Verificar si el archivo objetivo est√° en la lista a mostrar
            const targetFileName = 'i1JbPV3BPqg - 1 - El feo 3';
            const foundInDisplay = videos.find(v => v.fileName === targetFileName);
            if (foundInDisplay) {
                console.log('‚úÖ [Frontend] Archivo objetivo est√° en la lista a mostrar');
            } else {
                console.log('‚ùå [Frontend] Archivo objetivo NO est√° en la lista a mostrar');
                console.log('Primeros 5 videos a mostrar:', videos.slice(0, 5).map(v => v.fileName));
            }
            
            // Limpiar selecci√≥n al recargar (opcional: comentar esta l√≠nea si se quiere mantener la selecci√≥n)
            // selectedVideos = [];
            
            // Contar cu√°ntas llamadas hay por cada grupo
            const groupCounts = new Map();
            videos.forEach(video => {
                if (video.group && video.group.trim()) {
                    const groupId = video.group.trim();
                    groupCounts.set(groupId, (groupCounts.get(groupId) || 0) + 1);
                }
            });
            
            let renderedCount = 0;
            let rowIdCounter = 0;
            videos.forEach((video, arrayIndex) => {
                const videoIndex = startIndex + arrayIndex;
                const isTargetVideo = video.fileName === targetFileName;
                if (isTargetVideo) {
                    console.log(`[Frontend] üîç Renderizando archivo objetivo: ${video.fileName}`);
                }
                
                try {
                const row = document.createElement('div');
                row.className = 'video-row';
                const currentRowId = rowIdCounter++;
                
                // Agregar clase si la llamada tiene un grupo Y hay al menos 2 llamadas con ese grupo
                if (video.group && video.group.trim()) {
                    const groupId = video.group.trim();
                    const count = groupCounts.get(groupId) || 0;
                    if (count >= 2) {
                        row.classList.add('has-group');
                    }
                }
                
                // Log para la llamada perdida (el ID se asignar√° al wrapper m√°s adelante)
                if (isTargetVideo) {
                    console.log(`[Frontend] üîç ID que se asignar√° a la llamada perdida: video-row-${currentRowId}`);
                }
                
                // Checkbox de selecci√≥n
                const selectCell = document.createElement('div');
                selectCell.className = 'video-cell select-column';
                const checkboxContainer = document.createElement('div');
                checkboxContainer.style.display = 'flex';
                checkboxContainer.style.flexDirection = 'column';
                checkboxContainer.style.alignItems = 'center';
                checkboxContainer.style.gap = '4px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'selection-checkbox';
                checkbox.id = `select-${videoIndex}`;
                checkbox.setAttribute('data-video-index', videoIndex);
                checkbox.onchange = function() {
                    handleVideoSelection(videoIndex, this.checked);
                };
                // Restaurar estado de selecci√≥n si existe
                if (selectedVideos.includes(videoIndex)) {
                    checkbox.checked = true;
                }
                checkboxContainer.appendChild(checkbox);
                
                // Bot√≥n para actualizar contenido completo
                const updateBtn = document.createElement('button');
                updateBtn.className = 'update-content-btn';
                updateBtn.textContent = 'üîÑ Actualizar';
                updateBtn.title = 'Actualizar todo el contenido de la llamada (audio, miniatura, metadata, etc.)';
                updateBtn.onclick = () => updateCallContent(videoIndex, video, updateBtn);
                checkboxContainer.appendChild(updateBtn);
                
                // Bot√≥n de generar/regenerar miniatura
                const generateBtn = document.createElement('button');
                generateBtn.className = 'generate-btn';
                const generateThumbIcon = document.createElement('span');
                generateThumbIcon.textContent = video.generatedThumbnailUrl ? 'üîÑ' : '‚ú®';
                const generateThumbText = document.createElement('span');
                generateThumbText.textContent = video.generatedThumbnailUrl ? 'Regenerar' : 'Generar';
                generateBtn.appendChild(generateThumbIcon);
                generateBtn.appendChild(generateThumbText);
                generateBtn.onclick = () => {
                    // Necesitamos encontrar el thumbnailContainer para esta funci√≥n
                    // Buscar el thumbnailContainer que corresponde a este videoIndex
                    const thumbContainers = document.querySelectorAll('.thumbnail-container');
                    let thumbContainer = null;
                    for (const container of thumbContainers) {
                        if (container.getAttribute('data-video-index') === String(videoIndex)) {
                            thumbContainer = container;
                            break;
                        }
                    }
                    if (thumbContainer) {
                        generateThumbnail(videoIndex, video, generateBtn, thumbContainer);
                    }
                };
                checkboxContainer.appendChild(generateBtn);
                
                // Bot√≥n para ver el prompt de la miniatura
                const viewPromptBtn = document.createElement('button');
                viewPromptBtn.className = 'generate-btn';
                const viewPromptIcon = document.createElement('span');
                viewPromptIcon.textContent = 'üìù';
                const viewPromptText = document.createElement('span');
                viewPromptText.textContent = 'Ver Prompt';
                viewPromptBtn.appendChild(viewPromptIcon);
                viewPromptBtn.appendChild(viewPromptText);
                viewPromptBtn.onclick = () => showThumbnailPromptModal(videoIndex, video);
                checkboxContainer.appendChild(viewPromptBtn);
                
                // Bot√≥n de resubir miniatura a YouTube (solo si el video ya est√° subido)
                const metadata = video.fullMetadata || {};
                const youtubeVideoUrl = metadata.youtubeVideoUrl || video.youtubeVideoUrl;
                if (video.youtubeUploaded && youtubeVideoUrl && video.generatedThumbnailUrl) {
                    const reuploadBtn = document.createElement('button');
                    reuploadBtn.className = 'generate-btn';
                    const reuploadIcon = document.createElement('span');
                    reuploadIcon.textContent = 'üì§';
                    const reuploadText = document.createElement('span');
                    reuploadText.textContent = 'Resubir a YouTube';
                    reuploadBtn.appendChild(reuploadIcon);
                    reuploadBtn.appendChild(reuploadText);
                    reuploadBtn.onclick = () => reuploadThumbnailToYouTube(videoIndex, video, reuploadBtn);
                    checkboxContainer.appendChild(reuploadBtn);
                }
                
                // Bot√≥n para subir miniatura desde el PC
                const uploadThumbnailBtn = document.createElement('button');
                uploadThumbnailBtn.className = 'generate-btn';
                const uploadThumbnailIcon = document.createElement('span');
                uploadThumbnailIcon.textContent = 'üìÅ';
                const uploadThumbnailText = document.createElement('span');
                uploadThumbnailText.textContent = 'Subir Miniatura';
                uploadThumbnailBtn.appendChild(uploadThumbnailIcon);
                uploadThumbnailBtn.appendChild(uploadThumbnailText);
                uploadThumbnailBtn.title = 'Subir una miniatura desde el PC';
                
                // Input file oculto
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                fileInput.id = `thumbnail-upload-${videoIndex}`;
                
                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    if (!file.type.startsWith('image/')) {
                        alert('Por favor, selecciona un archivo de imagen');
                        return;
                    }
                    
                    // Deshabilitar bot√≥n y mostrar loading
                    uploadThumbnailBtn.disabled = true;
                    const originalText = uploadThumbnailBtn.textContent;
                    uploadThumbnailBtn.textContent = 'Subiendo...';
                    
                    try {
                        const formData = new FormData();
                        formData.append('thumbnail', file);
                        formData.append('fileName', video.fileName);
                        
                        const response = await fetch(`${API_BASE}/api/video/upload-thumbnail`, {
                            method: 'POST',
                            body: formData,
                        });
                        
                        const data = await response.json();
                        
                        if (response.ok && data.success) {
                            // Actualizar la imagen en la tabla
                            const imgId = `generated-thumb-${videoIndex}`;
                            let img = document.getElementById(imgId);
                            
                            if (!img || img.tagName !== 'IMG') {
                                // Si no existe o es un placeholder, crear nueva imagen
                                const thumbContainer = document.querySelector(`[data-video-index="${videoIndex}"]`);
                                if (thumbContainer) {
                                    img = document.createElement('img');
                                    img.className = 'thumbnail thumbnail-clickable';
                                    img.alt = 'Miniatura generada';
                                    img.id = imgId;
                                    img.loading = 'lazy';
                                    img.onclick = (e) => {
                                        e.stopPropagation();
                                        showImageModal(data.thumbnailUrl, 'Miniatura Generada');
                                    };
                                    img.onerror = function() {
                                        const placeholder = document.createElement('div');
                                        placeholder.className = 'thumbnail-placeholder';
                                        placeholder.id = imgId;
                                        placeholder.textContent = 'Sin imagen';
                                        this.parentElement.replaceChild(placeholder, this);
                                    };
                                    // Insertar la imagen al inicio del thumbnailContainer
                                    thumbContainer.insertBefore(img, thumbContainer.firstChild);
                                }
                            }
                            
                            // Actualizar la URL de la imagen con un timestamp para forzar recarga
                            const newUrl = `/api/video/thumbnail/generated/${encodeURIComponent(video.fileName)}?t=${Date.now()}`;
                            img.src = newUrl;
                            
                            // Actualizar el bot√≥n de generar (est√° en el checkboxContainer ahora)
                            // Buscar el bot√≥n de generar en el checkboxContainer de esta fila
                            const rowElement = document.querySelector(`input[type="checkbox"][data-video-index="${videoIndex}"]`)?.closest('tr');
                            if (rowElement) {
                                const checkboxContainer = rowElement.querySelector('.checkbox-container');
                                if (checkboxContainer) {
                                    const generateBtn = checkboxContainer.querySelector('.generate-btn');
                                    if (generateBtn) {
                                        const generateText = generateBtn.querySelector('span:last-child');
                                        if (generateText && generateText.textContent.includes('Generar')) {
                                            const generateIcon = generateBtn.querySelector('span:first-child');
                                            if (generateIcon) {
                                                generateIcon.textContent = 'üîÑ';
                                            }
                                            generateText.textContent = 'Regenerar';
                                        }
                                    }
                                }
                            }
                            
                            // Mostrar mensaje de √©xito
                            const successMsg = document.createElement('div');
                            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                            successMsg.textContent = '‚úÖ Miniatura subida exitosamente';
                            document.body.appendChild(successMsg);
                            
                            setTimeout(() => {
                                successMsg.remove();
                            }, 3000);
                        } else {
                            throw new Error(data.error || data.message || 'Error al subir miniatura');
                        }
                    } catch (error) {
                        alert(`Error al subir miniatura: ${error.message}`);
                    } finally {
                        // Rehabilitar bot√≥n
                        uploadThumbnailBtn.disabled = false;
                        uploadThumbnailBtn.textContent = originalText;
                        // Limpiar el input
                        fileInput.value = '';
                    }
                };
                
                uploadThumbnailBtn.onclick = () => {
                    fileInput.click();
                };
                
                checkboxContainer.appendChild(fileInput);
                checkboxContainer.appendChild(uploadThumbnailBtn);
                
                selectCell.appendChild(checkboxContainer);
                
                // Miniatura Original
                const originalThumbCell = document.createElement('div');
                originalThumbCell.className = 'video-cell thumbnail-cell thumbnail-original-column';
                
                // Verificar el estado del toggle de miniaturas originales y aplicar la clase hidden si est√° desactivado
                const showOriginalCheckbox = document.getElementById('showOriginalThumbnails');
                if (showOriginalCheckbox && !showOriginalCheckbox.checked) {
                    originalThumbCell.classList.add('hidden');
                }
                
                const originalThumbnailContainer = document.createElement('div');
                originalThumbnailContainer.className = 'thumbnail-container';
                originalThumbnailContainer.setAttribute('data-video-index', videoIndex);
                
                // Loading overlay
                const originalLoadingOverlay = document.createElement('div');
                originalLoadingOverlay.className = 'thumbnail-loading';
                originalLoadingOverlay.innerHTML = '<div class="spinner"></div><p>Descargando...</p>';
                originalThumbnailContainer.appendChild(originalLoadingOverlay);
                
                // Imagen o placeholder (lazy loading)
                if (video.originalThumbnailUrl) {
                    const img = document.createElement('img');
                    img.className = 'thumbnail thumbnail-clickable';
                    img.alt = 'Miniatura original';
                    img.id = `original-thumb-${videoIndex}`;
                    img.loading = 'lazy'; // Lazy loading nativo del navegador
                    img.dataset.src = video.originalThumbnailUrl; // Guardar URL en data-src
                    img.onclick = (e) => {
                        e.stopPropagation();
                        showImageModal(video.originalThumbnailUrl, 'Miniatura Original');
                    };
                    img.onerror = function() {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'thumbnail-placeholder';
                        placeholder.id = `original-thumb-${videoIndex}`;
                        placeholder.textContent = 'Sin imagen';
                        this.parentElement.replaceChild(placeholder, this);
                    };
                    // Cargar imagen cuando sea visible
                    const originalObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const targetImg = entry.target;
                                if (targetImg.dataset.src) {
                                    targetImg.src = targetImg.dataset.src;
                                    targetImg.removeAttribute('data-src');
                                }
                                originalObserver.unobserve(targetImg);
                            }
                        });
                    }, { rootMargin: '50px' }); // Cargar 50px antes de que sea visible
                    originalThumbnailContainer.appendChild(img);
                    originalObserver.observe(img);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'thumbnail-placeholder';
                    placeholder.id = `original-thumb-${videoIndex}`;
                    placeholder.textContent = 'Sin imagen';
                    originalThumbnailContainer.appendChild(placeholder);
                }
                
                // Bot√≥n de descargar/regenerar
                const downloadOriginalBtn = document.createElement('button');
                downloadOriginalBtn.className = 'generate-btn';
                downloadOriginalBtn.textContent = video.originalThumbnailUrl ? 'üîÑ Regenerar' : '‚¨áÔ∏è Descargar';
                downloadOriginalBtn.onclick = () => downloadOriginalThumbnail(videoIndex, video, downloadOriginalBtn, originalThumbnailContainer);
                originalThumbnailContainer.appendChild(downloadOriginalBtn);
                
                originalThumbCell.appendChild(originalThumbnailContainer);
                
                // Miniatura Generada
                const generatedThumbCell = document.createElement('div');
                generatedThumbCell.className = 'video-cell thumbnail-cell';
                const thumbnailContainer = document.createElement('div');
                thumbnailContainer.className = 'thumbnail-container';
                thumbnailContainer.setAttribute('data-video-index', videoIndex);
                
                // Loading overlay
                const loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'thumbnail-loading';
                loadingOverlay.innerHTML = '<div class="spinner"></div><p>Generando...</p>';
                thumbnailContainer.appendChild(loadingOverlay);
                
                // Imagen o placeholder (lazy loading)
                if (video.generatedThumbnailUrl) {
                    const img = document.createElement('img');
                    img.className = 'thumbnail thumbnail-clickable';
                    img.alt = 'Miniatura generada';
                    img.id = `generated-thumb-${videoIndex}`;
                    img.loading = 'lazy'; // Lazy loading nativo del navegador
                    img.dataset.src = video.generatedThumbnailUrl; // Guardar URL en data-src
                    img.onclick = (e) => {
                        e.stopPropagation();
                        showImageModal(video.generatedThumbnailUrl, 'Miniatura Generada');
                    };
                    img.onerror = function() {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'thumbnail-placeholder';
                        placeholder.id = `generated-thumb-${videoIndex}`;
                        placeholder.textContent = 'Sin imagen';
                        this.parentElement.replaceChild(placeholder, this);
                    };
                    // Cargar imagen cuando sea visible
                    const generatedObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const targetImg = entry.target;
                                if (targetImg.dataset.src) {
                                    targetImg.src = targetImg.dataset.src;
                                    targetImg.removeAttribute('data-src');
                                }
                                generatedObserver.unobserve(targetImg);
                            }
                        });
                    }, { rootMargin: '50px' }); // Cargar 50px antes de que sea visible
                    thumbnailContainer.appendChild(img);
                    generatedObserver.observe(img);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'thumbnail-placeholder';
                    placeholder.id = `generated-thumb-${videoIndex}`;
                    placeholder.textContent = 'Sin imagen';
                    thumbnailContainer.appendChild(placeholder);
                }
                
                generatedThumbCell.appendChild(thumbnailContainer);
                
                // T√≠tulo (fusionado con ID de YouTube)
                const titleCell = document.createElement('div');
                titleCell.className = 'video-cell title-cell';
                
                // Contenedor para ID y t√≠tulo
                const titleContainer = document.createElement('div');
                titleContainer.className = 'title-container';
                titleContainer.style.display = 'flex';
                titleContainer.style.flexDirection = 'column';
                titleContainer.style.gap = '4px';
                
                // ID de YouTube (arriba)
                const youtubeIdDiv = document.createElement('div');
                youtubeIdDiv.style.fontFamily = 'monospace';
                youtubeIdDiv.style.fontSize = '12px';
                youtubeIdDiv.style.color = '#666';
                if (video.youtubeVideoId) {
                    const callNumber = video.callNumber || 1;
                    const totalCalls = video.totalCallsInVideo || 0;
                    if (totalCalls > 0) {
                        youtubeIdDiv.textContent = `${video.youtubeVideoId} (${callNumber}/${totalCalls})`;
                    } else {
                        youtubeIdDiv.textContent = video.youtubeVideoId;
                    }
                } else {
                    youtubeIdDiv.textContent = '-';
                }
                titleContainer.appendChild(youtubeIdDiv);
                
                // T√≠tulo (abajo)
                const titleWrapper = document.createElement('div');
                titleWrapper.style.display = 'flex';
                titleWrapper.style.alignItems = 'center';
                titleWrapper.style.gap = '8px';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'title title-editable';
                titleDiv.textContent = video.title;
                titleDiv.setAttribute('data-original-title', video.title);
                titleDiv.setAttribute('data-file-name', video.fileName);
                titleDiv.onclick = (e) => {
                    e.stopPropagation();
                    makeTitleEditable(titleDiv, video, videoIndex);
                };
                titleWrapper.appendChild(titleDiv);
                
                // Bot√≥n para colapsar/expandir (solo si est√° subido a YouTube)
                if (video.youtubeUploaded) {
                    const collapseBtn = document.createElement('button');
                    collapseBtn.className = 'collapse-toggle-btn collapsed';
                    collapseBtn.innerHTML = '‚ñº Expandir';
                    collapseBtn.title = 'Expandir/Colapsar detalles';
                    collapseBtn.setAttribute('data-container-id', `video-details-${currentRowId}`);
                    collapseBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleRowCollapse(collapseBtn);
                    };
                    titleWrapper.appendChild(collapseBtn);
                }
                
                titleContainer.appendChild(titleWrapper);
                
                // Descripci√≥n (abajo del t√≠tulo)
                const descDiv = document.createElement('div');
                descDiv.className = 'description';
                descDiv.innerHTML = escapeHtml(video.description || 'Sin descripci√≥n');
                titleContainer.appendChild(descDiv);
                
                titleCell.appendChild(titleContainer);
                
                // Celda combinada: Fecha, Llamante, Ver video y Subir
                const combinedCell = document.createElement('div');
                combinedCell.className = 'video-cell';
                
                const combinedContainer = document.createElement('div');
                combinedContainer.style.display = 'flex';
                combinedContainer.style.flexDirection = 'column';
                combinedContainer.style.gap = '8px';
                
                // Fecha
                const dateDiv = document.createElement('div');
                dateDiv.className = 'date';
                dateDiv.textContent = video.date || '-';
                combinedContainer.appendChild(dateDiv);
                
                // Llamante
                const callerDiv = document.createElement('div');
                callerDiv.className = 'caller-info';
                if (video.name || video.age) {
                    if (video.name) {
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'caller-name';
                        nameSpan.textContent = escapeHtml(video.name);
                        callerDiv.appendChild(nameSpan);
                    }
                    if (video.age) {
                        const ageSpan = document.createElement('span');
                        ageSpan.className = 'caller-age';
                        ageSpan.textContent = ` (${video.age} a√±os)`;
                        callerDiv.appendChild(ageSpan);
                    }
                } else {
                    callerDiv.textContent = '-';
                }
                combinedContainer.appendChild(callerDiv);
                
                // Bot√≥n Ver video
                if (video.youtubeUrl) {
                    const link = document.createElement('a');
                    link.href = video.youtubeUrl;
                    link.target = '_blank';
                    link.className = 'youtube-link';
                    link.innerHTML = '‚ñ∂Ô∏è Ver video';
                    combinedContainer.appendChild(link);
                }
                
                // Bot√≥n Subir
                const uploadBtn = document.createElement('button');
                uploadBtn.className = 'upload-youtube-btn';
                uploadBtn.style.cssText = 'background: #FF0000; color: white; border: none; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; width: fit-content;';
                uploadBtn.innerHTML = video.youtubeUploaded ? '‚úÖ Subido' : 'üì§ Subir';
                uploadBtn.title = video.youtubeUploaded ? `Subido a YouTube: ${video.youtubeVideoUrl || 'N/A'}` : 'Subir video a YouTube';
                uploadBtn.disabled = video.youtubeUploaded;
                if (video.youtubeUploaded) {
                    uploadBtn.style.opacity = '0.7';
                    uploadBtn.style.cursor = 'not-allowed';
                }
                uploadBtn.onclick = () => uploadVideoToYouTube(videoIndex, video, uploadBtn);
                combinedContainer.appendChild(uploadBtn);
                
                // Badge de video si existe
                if (video.hasVideo) {
                    const videoBadge = document.createElement('span');
                    videoBadge.style.cssText = 'display: inline-block; background: #4CAF50; color: white; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; width: fit-content;';
                    videoBadge.innerHTML = '‚úÖ Video';
                    videoBadge.title = 'Video generado disponible';
                    combinedContainer.appendChild(videoBadge);
                }
                
                combinedCell.appendChild(combinedContainer);
                
                // Acciones
                const actionCell = document.createElement('div');
                actionCell.className = 'video-cell action-cell';
                
                const regenerateTitleBtn = document.createElement('button');
                regenerateTitleBtn.className = 'regenerate-title-btn';
                const regenerateIcon = document.createElement('span');
                regenerateIcon.className = 'icon';
                regenerateIcon.textContent = '‚úèÔ∏è';
                const regenerateText = document.createElement('span');
                regenerateText.className = 'text';
                regenerateText.textContent = 'Regenerar T√≠tulo';
                regenerateTitleBtn.appendChild(regenerateIcon);
                regenerateTitleBtn.appendChild(regenerateText);
                regenerateTitleBtn.onclick = () => regenerateTitleRecord(videoIndex, video, regenerateTitleBtn, row);
                actionCell.appendChild(regenerateTitleBtn);
                
                const generateVideoBtn = document.createElement('button');
                generateVideoBtn.className = 'generate-video-btn';
                const generateIcon = document.createElement('span');
                generateIcon.className = 'icon';
                generateIcon.textContent = 'üé¨';
                const generateText = document.createElement('span');
                generateText.className = 'text';
                generateText.textContent = 'Generar Video';
                generateVideoBtn.appendChild(generateIcon);
                generateVideoBtn.appendChild(generateText);
                generateVideoBtn.onclick = () => generateVideoFromCall(videoIndex, video, generateVideoBtn);
                actionCell.appendChild(generateVideoBtn);
                
                const generateShortBtn = document.createElement('button');
                generateShortBtn.className = 'generate-short-btn';
                const generateShortIcon = document.createElement('span');
                generateShortIcon.className = 'icon';
                generateShortIcon.textContent = 'üì±';
                const generateShortText = document.createElement('span');
                generateShortText.className = 'text';
                generateShortText.textContent = 'Generar Short';
                generateShortBtn.appendChild(generateShortIcon);
                generateShortBtn.appendChild(generateShortText);
                generateShortBtn.onclick = () => generateShortFromCall(videoIndex, video, generateShortBtn);
                actionCell.appendChild(generateShortBtn);
                
                // Los botones de Eliminar y Lista negra se movieron a la columna de Opciones
                
                const editMetadataBtn = document.createElement('button');
                editMetadataBtn.className = 'edit-metadata-btn';
                const editIcon = document.createElement('span');
                editIcon.className = 'icon';
                editIcon.textContent = 'üìù';
                const editText = document.createElement('span');
                editText.className = 'text';
                editText.textContent = 'Editar Metadata';
                editMetadataBtn.appendChild(editIcon);
                editMetadataBtn.appendChild(editText);
                editMetadataBtn.onclick = () => editMetadataRecord(videoIndex, video, editMetadataBtn);
                actionCell.appendChild(editMetadataBtn);
                
                // Bot√≥n de Pinecone
                const pineconeBtn = document.createElement('button');
                pineconeBtn.className = 'pinecone-btn';
                pineconeBtn.id = `pinecone-btn-${videoIndex}`;
                const pineconeIcon = document.createElement('span');
                pineconeIcon.className = 'icon';
                pineconeIcon.textContent = 'üìä';
                const pineconeText = document.createElement('span');
                pineconeText.className = 'text';
                pineconeText.textContent = 'Subir embedding';
                pineconeBtn.appendChild(pineconeIcon);
                pineconeBtn.appendChild(pineconeText);
                pineconeBtn.onclick = () => uploadToPinecone(videoIndex, video, pineconeBtn);
                
                // Actualizar estado del bot√≥n basado en metadata
                if (video.pineconeUploaded) {
                    // Cuando ya est√° subido, convertir el bot√≥n en "Re-subir Embedding"
                    pineconeBtn.disabled = false;
                    pineconeBtn.style.opacity = '1';
                    pineconeIcon.textContent = 'üîÑ';
                    pineconeText.textContent = 'Re-subir Embedding';
                    pineconeBtn.title = 'Re-subir el embedding a Pinecone con el nuevo formato (nombre, edad, descripci√≥n, resumen).';
                    pineconeBtn.onclick = () => resubmitEmbeddingToPinecone(videoIndex, video, pineconeBtn);
                } else if (video.relatedCalls && video.relatedCalls.length > 0) {
                    pineconeText.textContent = `üîó Relacionadas (${video.relatedCalls.length})`;
                    pineconeBtn.title = `Llamadas relacionadas: ${video.relatedCalls.join(', ')}`;
                }
                
                actionCell.appendChild(pineconeBtn);
                
                // Bot√≥n de Validar similitudes (solo si ya est√° subido a Pinecone)
                if (video.pineconeUploaded) {
                    const revalidateBtn = document.createElement('button');
                    revalidateBtn.className = 'pinecone-btn revalidate-btn';
                    revalidateBtn.id = `revalidate-btn-${videoIndex}`;
                    const revalidateIcon = document.createElement('span');
                    revalidateIcon.textContent = 'üîç';
                    const revalidateText = document.createElement('span');
                    revalidateText.textContent = 'Validar similitudes';
                    revalidateBtn.appendChild(revalidateIcon);
                    revalidateBtn.appendChild(revalidateText);
                    revalidateBtn.title = 'Validar similitudes usando el embedding existente para detectar llamadas relacionadas';
                    revalidateBtn.onclick = () => revalidateCallInPinecone(videoIndex, video, revalidateBtn);
                    actionCell.appendChild(revalidateBtn);
                }
                
                row.appendChild(selectCell);
                row.appendChild(originalThumbCell);
                row.appendChild(generatedThumbCell);
                row.appendChild(titleCell);
                row.appendChild(combinedCell);
                row.appendChild(actionCell);
                
                // Crear wrapper para la fila y los detalles
                const rowWrapper = document.createElement('div');
                rowWrapper.className = 'video-row-wrapper';
                rowWrapper.id = `video-row-${currentRowId}`;
                
                // Contenedor colapsable para los detalles (fuera del grid)
                const detailsContainer = document.createElement('div');
                detailsContainer.className = 'video-details-container';
                detailsContainer.id = `video-details-${currentRowId}`;
                
                // Colapsar por defecto si est√° subido a YouTube
                if (video.youtubeUploaded) {
                    detailsContainer.classList.add('collapsed');
                    row.classList.add('collapsed');
                }
                
                // Contenido de los detalles (se llenar√° despu√©s)
                const detailsContent = document.createElement('div');
                detailsContent.className = 'video-details-content';
                detailsContent.id = `video-details-content-${currentRowId}`;
                
                detailsContainer.appendChild(detailsContent);
                
                // Agregar la fila y el contenedor de detalles al wrapper
                rowWrapper.appendChild(row);
                rowWrapper.appendChild(detailsContainer);
                
                body.appendChild(rowWrapper);
                
                // Log para la llamada perdida despu√©s de agregar al DOM
                if (isTargetVideo) {
                    console.log(`[Frontend] ‚úÖ Fila principal agregada al DOM con ID: ${rowWrapper.id}`);
                    console.log(`[Frontend] üìç Elemento en DOM:`, document.getElementById(rowWrapper.id));
                }
                
                // Mover todo el contenido adicional a la celda de detalles
                // El contenido se agregar√° a detailsContent que ya fue creado arriba
                
                // Bot√≥n de play para el audio (fuera del contenido, a la derecha)
                const playBtn = document.createElement('button');
                playBtn.className = 'play-audio-btn';
                playBtn.innerHTML = '‚ñ∂Ô∏è';
                playBtn.id = `play-btn-${videoIndex}`;
                playBtn.title = 'Reproducir'; // Tooltip para accesibilidad
                
                // Bot√≥n de descarga de audio
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'audio-download-btn';
                downloadBtn.innerHTML = '‚¨áÔ∏è';
                downloadBtn.id = `download-btn-${videoIndex}`;
                downloadBtn.title = 'Descargar audio desde YouTube';
                
                // Bot√≥n de normalizaci√≥n de audio
                const normalizeBtn = document.createElement('button');
                normalizeBtn.className = 'audio-normalize-btn';
                normalizeBtn.innerHTML = 'üîä';
                normalizeBtn.id = `normalize-btn-${videoIndex}`;
                normalizeBtn.title = 'Normalizar audio';
                
                // Bot√≥n de compresi√≥n din√°mica de audio
                const compressBtn = document.createElement('button');
                compressBtn.className = 'audio-compress-btn';
                compressBtn.innerHTML = 'üóúÔ∏è';
                compressBtn.id = `compress-btn-${videoIndex}`;
                compressBtn.title = 'Comprimir audio (reduce picos altos y aumenta partes bajas)';
                
                // Bot√≥n de recortar audio
                const trimBtn = document.createElement('button');
                trimBtn.className = 'audio-trim-btn';
                trimBtn.innerHTML = '‚úÇÔ∏è';
                trimBtn.id = `trim-btn-${videoIndex}`;
                trimBtn.title = 'Recortar audio';
                
                // Elemento de audio oculto (NO asignar src hasta que se presione play)
                const audioElement = document.createElement('audio');
                audioElement.className = 'audio-player-hidden';
                audioElement.id = `audio-player-${videoIndex}`;
                audioElement.preload = 'none'; // No cargar nada hasta que se presione play
                // NO asignar src aqu√≠ - solo cuando se presione el bot√≥n
                
                // Construir ruta del audio (pero NO asignarla todav√≠a)
                let audioFileName = null;
                if (video.fileName) {
                    audioFileName = video.fileName + '.mp3';
                }
                
                // Variables para el estado del audio (disponibles para todas las funciones)
                let isPlaying = false;
                let audioLoaded = false;
                let canPlayHandler = null;
                let errorHandler = null;
                let endedHandler = null;
                let animationFrameId = null;
                
                // Funci√≥n para actualizar posici√≥n del marcador de reproducci√≥n
                const updatePlaybackPosition = () => {
                    if (audioElement.duration && audioElement.duration > 0) {
                        const percent = (audioElement.currentTime / audioElement.duration) * 100;
                        const clampedPercent = Math.max(0, Math.min(100, percent));
                        playbackMarker.style.left = `${clampedPercent}%`;
                        
                        // Asegurar que el marcador est√© visible
                        if (playbackMarker.style.display !== 'block') {
                            playbackMarker.style.display = 'block';
                        }
                    }
                };
                
                // Funci√≥n para actualizar continuamente usando requestAnimationFrame
                const animatePlaybackPosition = () => {
                    if (isPlaying && audioElement.duration) {
                        updatePlaybackPosition();
                        animationFrameId = requestAnimationFrame(animatePlaybackPosition);
                    }
                };
                
                // Iniciar animaci√≥n cuando el audio comience a reproducirse
                const startPlaybackAnimation = () => {
                    if (isPlaying) {
                        animatePlaybackPosition();
                    }
                };
                
                // Detener animaci√≥n cuando el audio se pause
                const stopPlaybackAnimation = () => {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                };
                
                if (audioFileName) {
                    // Funci√≥n helper para sincronizar el bot√≥n de opciones
                    const syncOptionsPlayBtn = () => {
                        const optionsPlayBtn = document.getElementById(`options-play-btn-${videoIndex}`);
                        if (optionsPlayBtn) {
                            if (isPlaying) {
                                optionsPlayBtn.innerHTML = '‚è∏Ô∏è';
                                optionsPlayBtn.title = 'Pausar audio';
                                optionsPlayBtn.style.background = '#f44336';
                            } else {
                                optionsPlayBtn.innerHTML = '‚ñ∂Ô∏è';
                                optionsPlayBtn.title = 'Reproducir audio';
                                optionsPlayBtn.style.background = '#4CAF50';
                            }
                        }
                    };
                    
                    // Funcionalidad de play/pause
                    
                    playBtn.onclick = () => {
                        if (isPlaying) {
                            // Pausar
                            audioElement.pause();
                            playBtn.innerHTML = '‚ñ∂Ô∏è';
                            playBtn.title = 'Reproducir';
                            playBtn.classList.remove('playing');
                            isPlaying = false;
                            syncOptionsPlayBtn(); // Sincronizar bot√≥n de opciones
                            // El marcador permanece visible en la posici√≥n actual al pausar
                            // Ocultar marcador de reproducci√≥n al pausar (opcional, puedes dejarlo visible)
                            // playbackMarker.style.display = 'none';
                        } else {
                            // Cargar el audio solo cuando se presiona play por primera vez
                            if (!audioLoaded) {
                                playBtn.disabled = true;
                                playBtn.innerHTML = '‚è≥';
                                playBtn.title = 'Cargando...';
                                
                                // Asignar la URL del audio solo AHORA, cuando se presiona el bot√≥n
                                const audioUrl = `${API_BASE}/api/video/audio/${encodeURIComponent(audioFileName)}`;
                                
                                // Remover src anterior si existe (por si acaso)
                                audioElement.removeAttribute('src');
                                audioElement.load(); // Resetear el elemento
                                
                                // Asignar el nuevo src
                                audioElement.src = audioUrl;
                                audioLoaded = true;
                                
                                // Intentar reproducir cuando el audio est√© listo
                                canPlayHandler = () => {
                                    playBtn.disabled = false;
                                    
                                    // Mostrar marcador de reproducci√≥n antes de reproducir
                                    playbackMarker.style.display = 'block';
                                    playbackMarker.style.left = '0%';
                                    console.log(`[Playback Marker] Marcador mostrado al iniciar reproducci√≥n`);
                                    
                                    audioElement.play().catch(err => {
                                        console.error('Error al reproducir audio:', err);
                                        playBtn.disabled = false;
                                        playBtn.innerHTML = '‚ùå';
                                        playBtn.title = 'Error';
                                        playBtn.style.opacity = '0.6';
                                        playbackMarker.style.display = 'none';
                                    });
                                    playBtn.innerHTML = '‚è∏Ô∏è';
                                    playBtn.title = 'Pausar';
                                    playBtn.classList.add('playing');
                                    isPlaying = true;
                                    syncOptionsPlayBtn(); // Sincronizar bot√≥n de opciones
                                    
                                    // Iniciar animaci√≥n de actualizaci√≥n continua
                                    startPlaybackAnimation();
                                };
                                audioElement.addEventListener('canplay', canPlayHandler, { once: true });
                                
                                // Actualizar posici√≥n cuando cambia el tiempo de reproducci√≥n (backup)
                                audioElement.addEventListener('timeupdate', updatePlaybackPosition);
                                
                                // Iniciar animaci√≥n cuando se reproduce
                                audioElement.addEventListener('play', startPlaybackAnimation);
                                
                                // Detener animaci√≥n cuando se pausa
                                audioElement.addEventListener('pause', stopPlaybackAnimation);
                                
                                // Detener animaci√≥n cuando termina
                                audioElement.addEventListener('ended', stopPlaybackAnimation);
                                
                                // Manejar errores de carga
                                errorHandler = () => {
                                    playBtn.disabled = false;
                                    playBtn.innerHTML = '‚ùå';
                                    playBtn.title = 'Error';
                                    playBtn.style.opacity = '0.6';
                                    audioLoaded = false;
                                };
                                audioElement.addEventListener('error', errorHandler, { once: true });
                                
                                // Forzar la carga solo cuando se presiona play
                                audioElement.load();
                            } else {
                                // Si ya est√° cargado, solo reproducir
                                audioElement.play().catch(err => {
                                    console.error('Error al reproducir audio:', err);
                                });
                                playBtn.innerHTML = '‚è∏Ô∏è';
                                playBtn.title = 'Pausar';
                                playBtn.classList.add('playing');
                                isPlaying = true;
                                syncOptionsPlayBtn(); // Sincronizar bot√≥n de opciones
                                
                                // Mostrar marcador de reproducci√≥n
                                playbackMarker.style.display = 'block';
                                playbackMarker.style.left = '0%';
                                
                                // Iniciar animaci√≥n de actualizaci√≥n continua
                                startPlaybackAnimation();
                            }
                        }
                    };
                    
                    // Actualizar bot√≥n cuando el audio termine (solo agregar una vez)
                    endedHandler = () => {
                        playBtn.innerHTML = '‚ñ∂Ô∏è';
                        playBtn.title = 'Reproducir';
                        playBtn.classList.remove('playing');
                        isPlaying = false;
                        syncOptionsPlayBtn(); // Sincronizar bot√≥n de opciones
                        // Resetear marcador de reproducci√≥n al finalizar
                        playbackMarker.style.left = '0%';
                    };
                    audioElement.addEventListener('ended', endedHandler);
                } else {
                    playBtn.disabled = true;
                    playBtn.style.opacity = '0.6';
                    playBtn.innerHTML = '‚ùå';
                    playBtn.title = 'Sin audio';
                }
                
                // Contenedor para los controles de audio
                const audioControlsContainer = document.createElement('div');
                audioControlsContainer.className = 'audio-controls-container';
                
                // Funcionalidad de descarga de audio
                if (video.youtubeUrl && video.fileName) {
                    downloadBtn.onclick = async () => {
                        try {
                            downloadBtn.disabled = true;
                            downloadBtn.innerHTML = '‚è≥';
                            downloadBtn.title = 'Descargando...';
                            
                            const response = await fetch(`${API_BASE}/api/video/audio/redownload`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    youtubeUrl: video.youtubeUrl,
                                    fileName: video.fileName,
                                }),
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok && data.success && data.downloadId) {
                                // Crear elemento de progreso
                                const title = `Descargando audio: ${video.title || video.fileName}`;
                                createProgressElement('download', data.downloadId, title, video.fileName);
                                
                                // Conectar a SSE
                                connectToProgressSSE('download', data.downloadId);
                                
                                // Guardar downloadId en localStorage
                                const stored = JSON.parse(localStorage.getItem('audioDownloads') || '[]');
                                if (!stored.includes(data.downloadId)) {
                                    stored.push(data.downloadId);
                                    localStorage.setItem('audioDownloads', JSON.stringify(stored));
                                }
                                
                                // El progreso se manejar√° autom√°ticamente a trav√©s de SSE
                                // Cuando termine, se actualizar√° la fila del video
                            } else {
                                throw new Error(data.error || data.message || 'Error al iniciar descarga de audio');
                            }
                        } catch (error) {
                            console.error('Error al descargar audio:', error);
                            alert(`Error al descargar audio: ${error.message}`);
                            downloadBtn.innerHTML = '‚ùå';
                            downloadBtn.title = 'Error al descargar';
                            setTimeout(() => {
                                downloadBtn.innerHTML = '‚¨áÔ∏è';
                                downloadBtn.title = 'Descargar audio desde YouTube';
                            }, 2000);
                        } finally {
                            downloadBtn.disabled = false;
                        }
                    };
                } else {
                    downloadBtn.disabled = true;
                    downloadBtn.style.opacity = '0.6';
                    downloadBtn.innerHTML = '‚ùå';
                    downloadBtn.title = 'Sin URL de YouTube o nombre de archivo';
                }
                
                // Funcionalidad de normalizaci√≥n de audio
                if (video.fileName) {
                    normalizeBtn.onclick = async () => {
                        try {
                            normalizeBtn.disabled = true;
                            normalizeBtn.innerHTML = '‚è≥';
                            normalizeBtn.title = 'Normalizando...';
                            
                            const response = await fetch(`${API_BASE}/api/video/audio/normalize`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    fileName: video.fileName,
                                }),
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok && data.success) {
                                // Actualizar el waveform basado en la duraci√≥n
                                await updateWaveform();
                                
                                // Si el audio estaba cargado, recargarlo
                                if (audioLoaded) {
                                    audioElement.removeAttribute('src');
                                    audioElement.load();
                                    audioLoaded = false;
                                    isPlaying = false;
                                    playBtn.innerHTML = '‚ñ∂Ô∏è';
                                    playBtn.title = 'Reproducir';
                                    playBtn.classList.remove('playing');
                                }
                                
                                normalizeBtn.innerHTML = '‚úÖ';
                                normalizeBtn.title = 'Audio normalizado';
                                setTimeout(() => {
                                    normalizeBtn.innerHTML = 'üîä';
                                    normalizeBtn.title = 'Normalizar audio';
                                }, 2000);
                            } else {
                                throw new Error(data.error || data.message || 'Error al normalizar audio');
                            }
                        } catch (error) {
                            console.error('Error al normalizar audio:', error);
                            alert(`Error al normalizar audio: ${error.message}`);
                            normalizeBtn.innerHTML = '‚ùå';
                            normalizeBtn.title = 'Error al normalizar';
                            setTimeout(() => {
                                normalizeBtn.innerHTML = 'üîä';
                                normalizeBtn.title = 'Normalizar audio';
                            }, 2000);
                        } finally {
                            normalizeBtn.disabled = false;
                        }
                    };
                } else {
                    normalizeBtn.disabled = true;
                    normalizeBtn.style.opacity = '0.6';
                    normalizeBtn.innerHTML = '‚ùå';
                    normalizeBtn.title = 'Sin nombre de archivo';
                }
                
                // Funcionalidad de compresi√≥n din√°mica de audio
                if (video.fileName) {
                    compressBtn.onclick = async () => {
                        // Confirmar compresi√≥n
                        const confirmMessage = `¬øComprimir din√°micamente el audio?\n\nEsto reducir√° los picos altos y aumentar√° las partes bajas para uniformar el volumen.\n\nEl archivo original se guardar√° como backup.`;
                        if (!confirm(confirmMessage)) {
                            return;
                        }
                        
                        try {
                            compressBtn.disabled = true;
                            compressBtn.innerHTML = '‚è≥';
                            compressBtn.title = 'Iniciando compresi√≥n...';
                            
                            const response = await fetch(`${API_BASE}/api/video/audio/compress`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    fileName: video.fileName,
                                }),
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok && data.success && data.compressionId) {
                                // Crear elemento de progreso
                                const title = `Comprimiendo audio: ${video.title || video.fileName}`;
                                createProgressElement('compress', data.compressionId, title, video.fileName);
                                
                                // Conectar a SSE
                                connectToProgressSSE('compress', data.compressionId);
                                
                                // Guardar compressionId en localStorage
                                const stored = JSON.parse(localStorage.getItem('audioCompressions') || '[]');
                                if (!stored.includes(data.compressionId)) {
                                    stored.push(data.compressionId);
                                    localStorage.setItem('audioCompressions', JSON.stringify(stored));
                                }
                                
                                // El progreso se manejar√° autom√°ticamente a trav√©s de SSE
                                // Cuando termine, se actualizar√° la fila del video
                            } else {
                                throw new Error(data.error || data.message || 'Error al iniciar compresi√≥n de audio');
                            }
                        } catch (error) {
                            console.error('Error al comprimir audio:', error);
                            alert(`Error al comprimir audio: ${error.message}`);
                            compressBtn.innerHTML = '‚ùå';
                            compressBtn.title = 'Error al comprimir';
                            setTimeout(() => {
                                compressBtn.innerHTML = 'üóúÔ∏è';
                                compressBtn.title = 'Comprimir audio (reduce picos altos y aumenta partes bajas)';
                            }, 2000);
                        } finally {
                            compressBtn.disabled = false;
                        }
                    };
                } else {
                    compressBtn.disabled = true;
                    compressBtn.style.opacity = '0.6';
                    compressBtn.innerHTML = '‚ùå';
                    compressBtn.title = 'Sin nombre de archivo';
                }
                
                // Funcionalidad de recorte de audio
                if (video.fileName) {
                    trimBtn.onclick = async () => {
                        // Si la duraci√≥n no est√° cargada, intentar cargarla
                        if (audioDuration === 0) {
                            trimBtn.disabled = true;
                            trimBtn.innerHTML = '‚è≥';
                            trimBtn.title = 'Cargando duraci√≥n...';
                            
                            const newDuration = await getAudioDuration();
                            if (newDuration === 0) {
                                const errorMsg = `No se pudo obtener la duraci√≥n del audio.\n\n` +
                                    `Archivo: ${video.fileName}.mp3\n\n` +
                                    `Por favor:\n` +
                                    `1. Verifica que el archivo existe en el servidor\n` +
                                    `2. Revisa la consola del navegador (F12) para m√°s detalles\n` +
                                    `3. Verifica los logs del servidor`;
                                alert(errorMsg);
                                trimBtn.disabled = false;
                                trimBtn.innerHTML = '‚úÇÔ∏è';
                                trimBtn.title = 'Recortar audio';
                                return;
                            }
                            
                            audioDuration = newDuration;
                            endTime = audioDuration;
                            updateMarkersFromTimes();
                            
                            // Restaurar opacidad de los marcadores si estaba reducida
                            startMarker.style.opacity = '1';
                            endMarker.style.opacity = '1';
                            
                            trimBtn.disabled = false;
                            trimBtn.innerHTML = '‚úÇÔ∏è';
                            trimBtn.title = 'Recortar audio';
                        }
                        
                        if (startTime >= endTime) {
                            alert('El tiempo de inicio debe ser menor que el tiempo de fin');
                            return;
                        }
                        
                        if (startTime < 0 || endTime > audioDuration) {
                            alert('Los tiempos de recorte est√°n fuera del rango v√°lido');
                            return;
                        }
                        
                        // Confirmar recorte
                        const confirmMessage = `¬øRecortar audio de ${startTime.toFixed(2)}s a ${endTime.toFixed(2)}s?`;
                        if (!confirm(confirmMessage)) {
                            return;
                        }
                        
                        try {
                            trimBtn.disabled = true;
                            trimBtn.innerHTML = '‚è≥';
                            trimBtn.title = 'Recortando...';
                            
                            const response = await fetch(`${API_BASE}/api/video/audio/trim`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    fileName: video.fileName,
                                    startTime: startTime,
                                    endTime: endTime,
                                }),
                            });
                            
                            const data = await response.json();
                            
                            if (response.ok && data.success && data.trimId) {
                                // Crear elemento de progreso
                                const title = `Recortando audio: ${video.title || video.fileName}`;
                                createProgressElement('trim', data.trimId, title, video.fileName);
                                
                                // Conectar a SSE
                                connectToProgressSSE('trim', data.trimId);
                                
                                // Guardar trimId en localStorage
                                const stored = JSON.parse(localStorage.getItem('audioTrims') || '[]');
                                if (!stored.includes(data.trimId)) {
                                    stored.push(data.trimId);
                                    localStorage.setItem('audioTrims', JSON.stringify(stored));
                                }
                                
                                // El progreso se manejar√° autom√°ticamente a trav√©s de SSE
                                // Cuando termine, se actualizar√° la fila del video
                            } else {
                                throw new Error(data.error || data.message || 'Error al iniciar recorte de audio');
                            }
                        } catch (error) {
                            console.error('Error al recortar audio:', error);
                            alert(`Error al recortar audio: ${error.message}`);
                            trimBtn.innerHTML = '‚ùå';
                            trimBtn.title = 'Error al recortar';
                            setTimeout(() => {
                                trimBtn.innerHTML = '‚úÇÔ∏è';
                                trimBtn.title = 'Recortar audio';
                            }, 2000);
                        } finally {
                            trimBtn.disabled = false;
                        }
                    };
                } else {
                    trimBtn.disabled = true;
                    trimBtn.style.opacity = '0.6';
                    trimBtn.innerHTML = '‚ùå';
                    trimBtn.title = 'Sin nombre de archivo';
                }
                
                // Bot√≥n Eliminar
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.title = 'Eliminar';
                const deleteIcon = document.createElement('span');
                deleteIcon.className = 'icon';
                deleteIcon.textContent = 'üóëÔ∏è';
                deleteBtn.appendChild(deleteIcon);
                deleteBtn.onclick = () => deleteCallRecord(videoIndex, video, deleteBtn, row);
                
                // Bot√≥n Lista Negra
                const blacklistBtn = document.createElement('button');
                blacklistBtn.className = 'blacklist-btn';
                blacklistBtn.title = 'Lista Negra';
                const blacklistIcon = document.createElement('span');
                blacklistIcon.className = 'icon';
                blacklistIcon.textContent = 'üö´';
                blacklistBtn.appendChild(blacklistIcon);
                blacklistBtn.onclick = () => blacklistCallRecord(videoIndex, video, blacklistBtn, row);
                
                audioControlsContainer.appendChild(playBtn);
                audioControlsContainer.appendChild(downloadBtn);
                audioControlsContainer.appendChild(normalizeBtn);
                audioControlsContainer.appendChild(compressBtn);
                audioControlsContainer.appendChild(trimBtn);
                audioControlsContainer.appendChild(deleteBtn);
                audioControlsContainer.appendChild(blacklistBtn);
                
                // Agregar contenido a detailsContent: primero el audioElement (oculto), luego se agregar√° el waveform y los controles
                detailsContent.appendChild(audioElement);
                
                // Contenedor del waveform con marcadores
                const waveformContainer = document.createElement('div');
                waveformContainer.className = 'waveform-container';
                waveformContainer.id = `waveform-container-${videoIndex}`;
                
                // Imagen de waveform del audio
                const waveformImg = document.createElement('img');
                waveformImg.id = `waveform-img-${videoIndex}`;
                waveformImg.style.cssText = 'height: 80px; object-fit: contain; display: block;';
                waveformImg.alt = 'Waveform del audio';
                waveformImg.style.display = 'none'; // Ocultar hasta que se cargue
                
                // Marcador de inicio
                const startMarker = document.createElement('div');
                startMarker.className = 'waveform-marker start';
                startMarker.id = `start-marker-${videoIndex}`;
                startMarker.style.left = '0%';
                startMarker.style.display = 'none';
                
                // Marcador de fin
                const endMarker = document.createElement('div');
                endMarker.className = 'waveform-marker end';
                endMarker.id = `end-marker-${videoIndex}`;
                endMarker.style.right = '0%';
                endMarker.style.display = 'none';
                
                // √Årea de selecci√≥n
                const selectionArea = document.createElement('div');
                selectionArea.className = 'waveform-selection';
                selectionArea.id = `selection-area-${videoIndex}`;
                selectionArea.style.display = 'none';
                
                // Marcador de posici√≥n de reproducci√≥n
                const playbackMarker = document.createElement('div');
                playbackMarker.className = 'waveform-playback-marker';
                playbackMarker.id = `playback-marker-${videoIndex}`;
                playbackMarker.style.left = '0%';
                
                waveformContainer.appendChild(waveformImg);
                waveformContainer.appendChild(selectionArea);
                waveformContainer.appendChild(startMarker);
                waveformContainer.appendChild(endMarker);
                waveformContainer.appendChild(playbackMarker);
                
                // Variables para el recorte
                let audioDuration = 0;
                let startTime = 0;
                let endTime = 0;
                let isDragging = false;
                let dragMarker = null;
                
                // Funci√≥n auxiliar para actualizar el waveform basado en la duraci√≥n
                const updateWaveform = async () => {
                    if (!video.fileName) return;
                    
                    try {
                        // Obtener duraci√≥n actualizada
                        const duration = await getAudioDuration();
                        
                        if (duration <= 0) {
                            console.warn('‚ö†Ô∏è No se pudo obtener la duraci√≥n del audio para actualizar waveform');
                            return;
                        }
                        
                        // Calcular ancho basado en duraci√≥n
                        const waveformWidth = Math.ceil(duration * WAVEFORM_PIXELS_PER_SECOND);
                        
                        const waveformResponse = await fetch(`${API_BASE}/api/video/audio/waveform?fileName=${encodeURIComponent(video.fileName)}&width=${waveformWidth}&t=${Date.now()}`);
                        const waveformData = await waveformResponse.json();
                        
                        if (waveformResponse.ok && waveformData.success && waveformData.image) {
                            // Crear una nueva imagen para pre-cargar
                            const newImg = new Image();
                            newImg.onload = () => {
                                waveformImg.src = waveformData.image;
                                waveformImg.style.display = 'block';
                                
                                // Ajustar el contenedor al ancho de la imagen
                                waveformContainer.style.width = `${waveformWidth}px`;
                                
                                // Actualizar marcadores despu√©s de que la imagen se cargue
                                updateMarkersFromTimes();
                            };
                            newImg.onerror = () => {
                                console.error('Error al cargar la nueva imagen del waveform');
                            };
                            // Iniciar la carga de la nueva imagen
                            newImg.src = waveformData.image;
                        }
                    } catch (error) {
                        console.error('Error al actualizar waveform:', error);
                    }
                };
                
                // Funci√≥n para obtener la duraci√≥n del audio
                const getAudioDuration = async () => {
                    if (!video.fileName) {
                        console.warn('No hay fileName para obtener duraci√≥n');
                        return 0;
                    }
                    
                    try {
                        const url = `${API_BASE}/api/video/audio/duration?fileName=${encodeURIComponent(video.fileName)}`;
                        //|console.log(`[getAudioDuration] Intentando obtener duraci√≥n para: ${video.fileName}`);
                        //console.log(`[getAudioDuration] URL: ${url}`);
                        
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        //console.log(`[getAudioDuration] Respuesta del servidor:`, { status: response.status, data });
                        
                        if (response.ok && data.success && data.duration) {
                            audioDuration = data.duration;
                            endTime = audioDuration;
                            console.log(`‚úÖ Duraci√≥n del audio cargada: ${audioDuration}s`);
                            return audioDuration;
                        } else {
                            console.error('‚ùå Error al obtener duraci√≥n:', {
                                status: response.status,
                                error: data.error || data.message || 'Error desconocido',
                                fileName: video.fileName,
                                searchedPath: data.searchedPath || 'N/A',
                                path: data.path || 'N/A',
                                data: data
                            });
                            if (response.status === 404) {
                                console.warn(`‚ö†Ô∏è Archivo de audio no encontrado: ${video.fileName}.mp3`);
                                console.warn(`‚ö†Ô∏è Ruta buscada: ${data.path || 'N/A'}`);
                                console.warn(`‚ö†Ô∏è Directorio de b√∫squeda: ${data.searchedPath || 'N/A'}`);
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Error al obtener duraci√≥n del audio:', error);
                        console.error('Stack:', error.stack);
                    }
                    return 0;
                };
                
                // Funci√≥n para actualizar la posici√≥n de los marcadores bas√°ndose en los tiempos
                const updateMarkersFromTimes = () => {
                    if (audioDuration === 0) return;
                    
                    // Usar el ancho real de la imagen en lugar del contenedor
                    const waveformWidth = audioDuration * WAVEFORM_PIXELS_PER_SECOND;
                    const startPercent = (startTime / audioDuration) * 100;
                    const endPercent = (endTime / audioDuration) * 100;
                    
                    startMarker.style.left = `${startPercent}%`;
                    endMarker.style.right = `${100 - endPercent}%`;
                    
                    // Actualizar √°rea de selecci√≥n
                    if (startPercent < endPercent) {
                        selectionArea.style.left = `${startPercent}%`;
                        selectionArea.style.width = `${endPercent - startPercent}%`;
                        selectionArea.style.display = 'block';
                    }
                };
                
                // Funci√≥n para actualizar los tiempos bas√°ndose en la posici√≥n de los marcadores
                const updateTimesFromMarkers = () => {
                    if (audioDuration === 0) return;
                    
                    // Los marcadores ya est√°n en porcentaje, as√≠ que podemos calcular directamente
                    const startPercent = parseFloat(startMarker.style.left) || 0;
                    const endPercent = 100 - (parseFloat(endMarker.style.right) || 0);
                    
                    startTime = (startPercent / 100) * audioDuration;
                    endTime = (endPercent / 100) * audioDuration;
                    
                    // Asegurar que startTime < endTime
                    if (startTime >= endTime) {
                        if (dragMarker === startMarker) {
                            startTime = Math.max(0, endTime - 0.1);
                        } else {
                            endTime = Math.min(audioDuration, startTime + 0.1);
                        }
                        updateMarkersFromTimes();
                    }
                };
                
                // Funciones de arrastre
                const handleMouseDown = (e, marker) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isDragging = true;
                    dragMarker = marker;
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging || !dragMarker || audioDuration === 0) return;
                    
                    // Obtener el ancho REAL de la imagen renderizada en el DOM
                    const waveformImgRect = waveformImg.getBoundingClientRect();
                    const waveformWidth = waveformImgRect.width || waveformImg.offsetWidth || (audioDuration * WAVEFORM_PIXELS_PER_SECOND);
                    
                    // Calcular la posici√≥n X relativa al inicio de la imagen
                    // La posici√≥n X del clic relativa al viewport menos la posici√≥n izquierda de la imagen
                    const x = e.clientX - waveformImgRect.left;
                    
                    // Calcular el porcentaje basado en el ancho real de la imagen
                    const percent = Math.max(0, Math.min(100, (x / waveformWidth) * 100));
                    
                    if (dragMarker === startMarker) {
                        const endPercent = 100 - (parseFloat(endMarker.style.right) || 0);
                        if (percent < endPercent) {
                            dragMarker.style.left = `${percent}%`;
                            startTime = (percent / 100) * audioDuration;
                            
                            // Actualizar √°rea de selecci√≥n
                            selectionArea.style.left = `${percent}%`;
                            selectionArea.style.width = `${endPercent - percent}%`;
                        }
                    } else if (dragMarker === endMarker) {
                        const startPercent = parseFloat(startMarker.style.left) || 0;
                        if (percent > startPercent) {
                            dragMarker.style.right = `${100 - percent}%`;
                            endTime = (percent / 100) * audioDuration;
                            
                            // Actualizar √°rea de selecci√≥n
                            selectionArea.style.left = `${startPercent}%`;
                            selectionArea.style.width = `${percent - startPercent}%`;
                        }
                    }
                };
                
                const handleMouseUp = () => {
                    isDragging = false;
                    dragMarker = null;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                
                startMarker.addEventListener('mousedown', (e) => handleMouseDown(e, startMarker));
                endMarker.addEventListener('mousedown', (e) => handleMouseDown(e, endMarker));
                
                // Funci√≥n para manejar clic en el waveform
                const handleWaveformClick = async (e) => {
                    // No hacer nada si se est√° arrastrando un marcador
                    if (isDragging) return;
                    
                    // No hacer nada si se hace clic directamente en un marcador
                    if (e.target === startMarker || e.target === endMarker || 
                        e.target === playbackMarker || startMarker.contains(e.target) || 
                        endMarker.contains(e.target) || playbackMarker.contains(e.target)) {
                        return;
                    }
                    
                    if (audioDuration === 0) {
                        // Intentar obtener la duraci√≥n si no est√° disponible
                        const duration = await getAudioDuration();
                        if (duration === 0) {
                            console.warn('No se puede hacer clic en el waveform: duraci√≥n no disponible');
                            return;
                        }
                    }
                    
                    // Obtener el ancho REAL de la imagen renderizada en el DOM
                    const waveformImgRect = waveformImg.getBoundingClientRect();
                    const waveformWidth = waveformImgRect.width || waveformImg.offsetWidth || (audioDuration * WAVEFORM_PIXELS_PER_SECOND);
                    
                    // Obtener la posici√≥n del contenedor con scroll (detailsContent) y considerar el scroll
                    const containerRect = detailsContent.getBoundingClientRect();
                    const containerScrollLeft = detailsContent.scrollLeft || 0;
                    
                    // Calcular la posici√≥n X relativa al inicio de la imagen
                    // La posici√≥n X del clic relativa al viewport menos la posici√≥n izquierda de la imagen
                    const x = e.clientX - waveformImgRect.left;
                    
                    // Asegurar que x est√© dentro del rango v√°lido
                    const clampedX = Math.max(0, Math.min(waveformWidth, x));
                    
                    // Calcular el tiempo en segundos basado en la posici√≥n
                    const clickTime = (clampedX / waveformWidth) * audioDuration;
                    const clampedClickTime = Math.max(0, Math.min(audioDuration, clickTime));
                    
                    // Actualizar la posici√≥n del marcador de reproducci√≥n
                    const percent = (clampedClickTime / audioDuration) * 100;
                    playbackMarker.style.left = `${percent}%`;
                    playbackMarker.style.display = 'block';
                    
                    console.log(`[Waveform Click] x: ${x}, clampedX: ${clampedX}, waveformWidth: ${waveformWidth}, clickTime: ${clampedClickTime}s, percent: ${percent}%, scrollLeft: ${containerScrollLeft}`);
                    
                    // Si el audio est√° cargado
                    if (audioLoaded && audioElement.duration) {
                        audioElement.currentTime = clampedClickTime;
                        // Solo reproducir si ya estaba reproduci√©ndose
                        if (isPlaying) {
                            // El audio ya est√° reproduci√©ndose, solo cambiar el tiempo
                            // No necesitamos hacer nada m√°s, el currentTime ya se actualiz√≥
                        } else {
                            // El audio est√° pausado, solo posicionar el marcador
                            // No reproducir, esperar a que el usuario presione play
                        }
                    } else if (audioFileName) {
                        // Si el audio no est√° cargado, cargarlo y posicionar en el punto seleccionado
                        // pero NO reproducir autom√°ticamente
                        playBtn.disabled = true;
                        playBtn.innerHTML = '‚è≥';
                        playBtn.title = 'Cargando...';
                        
                        const audioUrl = `${API_BASE}/api/video/audio/${encodeURIComponent(audioFileName)}`;
                        
                        // Remover src anterior si existe
                        audioElement.removeAttribute('src');
                        audioElement.load();
                        
                        // Asignar el nuevo src
                        audioElement.src = audioUrl;
                        audioLoaded = true;
                        
                        // Esperar a que el audio est√© listo y luego establecer el tiempo (sin reproducir)
                        const seekOnly = () => {
                            audioElement.currentTime = clampedClickTime;
                            playBtn.disabled = false;
                            playBtn.innerHTML = '‚ñ∂Ô∏è';
                            playBtn.title = 'Reproducir';
                            playBtn.classList.remove('playing');
                            isPlaying = false;
                            // El audio est√° cargado y posicionado, pero no reproduci√©ndose
                        };
                        
                        audioElement.addEventListener('canplay', seekOnly, { once: true });
                        audioElement.load();
                    }
                };
                
                // Agregar event listener para clic en el waveform
                waveformContainer.addEventListener('click', handleWaveformClick);
                
                // Funci√≥n para cargar el waveform
                const loadWaveform = async () => {
                    if (!video.fileName) return;
                    
                    try {
                        // Obtener duraci√≥n primero para calcular el ancho
                        const duration = await getAudioDuration();
                        
                        if (duration <= 0) {
                            console.warn('‚ö†Ô∏è No se pudo obtener la duraci√≥n del audio, usando ancho por defecto');
                            // Usar ancho por defecto si no se puede obtener la duraci√≥n
                            const defaultWidth = 800;
                            const response = await fetch(`${API_BASE}/api/video/audio/waveform?fileName=${encodeURIComponent(video.fileName)}&width=${defaultWidth}`);
                            const data = await response.json();
                            
                            if (response.ok && data.success && data.image) {
                                waveformImg.src = data.image;
                                waveformImg.style.display = 'block';
                            }
                            return;
                        }
                        
                        // Calcular ancho basado en duraci√≥n
                        const waveformWidth = Math.ceil(duration * WAVEFORM_PIXELS_PER_SECOND);
                        
                        const response = await fetch(`${API_BASE}/api/video/audio/waveform?fileName=${encodeURIComponent(video.fileName)}&width=${waveformWidth}`);
                        const data = await response.json();
                        
                        if (response.ok && data.success && data.image) {
                            waveformImg.src = data.image;
                            waveformImg.style.display = 'block';
                            
                            // Ajustar el contenedor al ancho de la imagen
                            waveformContainer.style.width = `${waveformWidth}px`;
                            
                            // Mostrar marcadores
                            startMarker.style.display = 'block';
                            endMarker.style.display = 'block';
                            updateMarkersFromTimes();
                            console.log(`‚úÖ Waveform cargado: ${waveformWidth}px de ancho (${duration}s √ó 50px/s)`);
                        }
                    } catch (error) {
                        console.error('Error al cargar waveform:', error);
                    }
                };
                
                // Cargar waveform cuando el contenedor est√© visible
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && waveformImg.style.display === 'none') {
                            loadWaveform();
                            observer.disconnect();
                        }
                    });
                }, { threshold: 0.1 });
                
                // Observar cuando el contenedor se agregue al DOM
                setTimeout(() => {
                    if (detailsContent.parentElement) {
                        observer.observe(detailsContent);
                    }
                }, 100);
                
                // Agregar primero el waveform (a la izquierda) y luego los controles (a la derecha)
                detailsContent.appendChild(waveformContainer);
                detailsContent.appendChild(audioControlsContainer);
                
                renderedCount++;
                if (isTargetVideo) {
                    console.log(`[Frontend] ‚úÖ Archivo objetivo renderizado exitosamente`);
                    console.log(`[Frontend] üìã IDs completos de la llamada perdida:`);
                    console.log(`   - Wrapper principal: ${rowWrapper.id}`);
                    console.log(`   - Detalles: ${detailsContainer.id}`);
                }
                } catch (error) {
                    console.error(`[Frontend] ‚ùå Error al renderizar video ${video.fileName}:`, error);
                    if (isTargetVideo) {
                        console.error(`[Frontend] ‚ùå Error espec√≠fico al renderizar archivo objetivo:`, error);
                        console.error('Stack:', error.stack);
                    }
                }
            });
            
            console.log(`[Frontend] Total de videos renderizados: ${renderedCount} de ${videos.length}`);
            
            // Verificar si el archivo objetivo est√° en el DOM
            const targetFileNameCheck = 'i1JbPV3BPqg - 1 - El feo 3';
            const targetVideoId = 'i1JbPV3BPqg';
            
            // Buscar por fileName en el array de videos
            const targetVideoIndex = videos.findIndex(v => v.fileName === targetFileNameCheck);
            console.log(`[Frontend] üîç B√∫squeda en DOM - targetVideoIndex: ${targetVideoIndex}`);
            
            // Buscar en todas las filas del body
            const allRows = Array.from(body.querySelectorAll('.video-row'));
            console.log(`[Frontend] üîç Total de filas en el DOM: ${allRows.length}`);
            
            // Buscar por checkbox con data-video-index
            const targetRow = allRows.find(tr => {
                const checkbox = tr.querySelector(`input[data-video-index]`);
                if (checkbox) {
                    const idx = parseInt(checkbox.getAttribute('data-video-index'));
                    const video = videos[idx];
                    if (video) {
                        return video.fileName === targetFileNameCheck || 
                               video.youtubeVideoId === targetVideoId ||
                               video.fileName.includes('i1JbPV3BPqg') ||
                               video.fileName.includes('feo');
                    }
                }
                return false;
            });
            
            // Buscar por texto en las celdas
            const targetRowByText = allRows.find(tr => {
                const text = tr.textContent || '';
                return text.includes('i1JbPV3BPqg') || text.includes('El feo 3');
            });
            
            // Buscar por ID de fila que contenga el videoId
            const targetRowById = allRows.find(tr => {
                const id = tr.id || '';
                return id.includes('i1JbPV3BPqg');
            });
            
            if (targetRow) {
                console.log('‚úÖ [Frontend] Archivo objetivo encontrado en el DOM por checkbox');
                console.log('   ID de la fila:', targetRow.id);
                console.log('   Elemento:', targetRow);
            } else if (targetRowByText) {
                console.log('‚úÖ [Frontend] Archivo objetivo encontrado en el DOM por texto');
                console.log('   ID de la fila:', targetRowByText.id);
                console.log('   Elemento:', targetRowByText);
            } else if (targetRowById) {
                console.log('‚úÖ [Frontend] Archivo objetivo encontrado en el DOM por ID');
                console.log('   ID de la fila:', targetRowById.id);
                console.log('   Elemento:', targetRowById);
            } else {
                console.log('‚ùå [Frontend] Archivo objetivo NO encontrado en el DOM');
                console.log('   B√∫squeda realizada en:', allRows.length, 'filas');
                console.log('   targetVideoIndex en array:', targetVideoIndex);
                if (targetVideoIndex >= 0) {
                    console.log('   ‚ö†Ô∏è El video est√° en el array pero no se renderiz√≥');
                    console.log('   Video data:', videos[targetVideoIndex]);
                } else {
                    console.log('   ‚ö†Ô∏è El video NO est√° en el array de videos a mostrar');
                }
                
                // Mostrar algunos ejemplos de filas para debugging
                console.log('   Primeras 5 filas en DOM:', allRows.slice(0, 5).map(tr => ({
                    id: tr.id,
                    hasCheckbox: !!tr.querySelector('input[data-video-index]'),
                    textPreview: (tr.textContent || '').substring(0, 100)
                })));
            }
            
            document.getElementById('tableContainer').style.display = 'block';
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function generateThumbnail(videoIndex, video, button, container) {
            if (!video.fullMetadata) {
                alert('Error: No se encontr√≥ el metadata completo del video');
                return;
            }
            
            // Verificar que el contenedor existe y es correcto
            if (!container) {
                console.error('[generateThumbnail] Contenedor no encontrado, buscando...');
                // Buscar el contenedor correcto por data-video-index
                const thumbContainers = document.querySelectorAll('.thumbnail-container[data-video-index]');
                for (const thumbContainer of thumbContainers) {
                    if (thumbContainer.getAttribute('data-video-index') === String(videoIndex)) {
                        container = thumbContainer;
                        console.log(`[generateThumbnail] Contenedor encontrado por data-video-index:`, container);
                        break;
                    }
                }
                
                // Si a√∫n no se encuentra, buscar por ID de imagen
                if (!container) {
                    const existingImg = document.getElementById(`generated-thumb-${videoIndex}`);
                    if (existingImg && existingImg.parentElement) {
                        container = existingImg.parentElement;
                        console.log(`[generateThumbnail] Contenedor encontrado por imagen existente:`, container);
                    }
                }
            }
            
            // Verificar que el contenedor es un .thumbnail-container
            if (container && !container.classList.contains('thumbnail-container')) {
                console.warn(`[generateThumbnail] El contenedor no tiene la clase thumbnail-container, buscando el correcto...`);
                const thumbContainer = container.querySelector('.thumbnail-container[data-video-index="' + videoIndex + '"]');
                if (thumbContainer) {
                    container = thumbContainer;
                }
            }
            
            if (!container || !container.classList.contains('thumbnail-container')) {
                console.error(`[generateThumbnail] No se encontr√≥ el contenedor de miniatura para videoIndex ${videoIndex}`);
                alert('Error: No se encontr√≥ el contenedor de miniatura');
                return;
            }
            
            console.log(`[generateThumbnail] Usando contenedor:`, container, `para videoIndex: ${videoIndex}`);
            console.log(`[generateThumbnail] Contenedor padre (thumbnail-cell):`, container.parentElement);
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const buttonText = button.querySelector('span:last-child');
            const buttonIcon = button.querySelector('span:first-child');
            const originalText = buttonText ? buttonText.textContent : '';
            const originalIcon = buttonIcon ? buttonIcon.textContent : '';
            if (buttonText) buttonText.textContent = 'Generando...';
            if (buttonIcon) buttonIcon.textContent = '‚è≥';
            const loadingOverlay = container.querySelector('.thumbnail-loading');
            if (loadingOverlay) {
                loadingOverlay.classList.add('active');
                loadingOverlay.style.display = 'block';
            }
            
            try {
                // Preparar el metadata para enviar
                const metadata = video.fullMetadata;
                
                // Crear FormData para enviar el metadata como JSON
                const formData = new FormData();
                const metadataBlob = new Blob([JSON.stringify(metadata)], { type: 'application/json' });
                formData.append('metadata', metadataBlob, 'metadata.json');
                formData.append('model', 'gpt-image-1.5');
                formData.append('size', '1536x1024');
                formData.append('quality', 'medium');
                formData.append('saveImagePrompt', 'false');
                
                const response = await fetch(`${API_BASE}/api/video/generate-thumbnail`, {
                    method: 'POST',
                    body: formData,
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Ocultar loading overlay completamente
                    const loadingOverlayInContainer = container.querySelector('.thumbnail-loading');
                    if (loadingOverlayInContainer) {
                        loadingOverlayInContainer.classList.remove('active');
                        loadingOverlayInContainer.style.display = 'none';
                    }
                    if (loadingOverlay) {
                        loadingOverlay.classList.remove('active');
                        loadingOverlay.style.display = 'none';
                    }
                    
                    // Actualizar la imagen en la tabla
                    const imgId = `generated-thumb-${videoIndex}`;
                    
                    // Verificar que el contenedor existe y es correcto
                    if (!container || !container.parentElement) {
                        console.error(`[generateThumbnail] Contenedor inv√°lido para videoIndex ${videoIndex}`);
                        throw new Error('Contenedor de miniatura no encontrado');
                    }
                    
                    // Ocultar loading overlay completamente
                    if (loadingOverlayInContainer) {
                        loadingOverlayInContainer.style.display = 'none';
                        loadingOverlayInContainer.classList.remove('active');
                    }
                    
                    // Eliminar cualquier elemento existente (imagen, placeholder, etc.) con el mismo ID o que sea placeholder
                    const existingElements = container.querySelectorAll(`#${imgId}, .thumbnail-placeholder, img.thumbnail`);
                    existingElements.forEach(el => {
                        if (el.id === imgId || el.classList.contains('thumbnail-placeholder') || 
                            (el.tagName === 'IMG' && el.classList.contains('thumbnail'))) {
                            el.remove();
                        }
                    });
                    
                    // Crear nueva imagen
                    const img = document.createElement('img');
                    img.id = imgId;
                    img.className = 'thumbnail thumbnail-clickable';
                    img.alt = 'Miniatura generada';
                    img.loading = 'eager'; // Cargar inmediatamente, no lazy loading
                    
                    // Actualizar la URL de la imagen con un timestamp para forzar recarga
                    const newUrl = `/api/video/thumbnail/generated/${encodeURIComponent(video.fileName)}?t=${Date.now()}`;
                    img.src = newUrl;
                    
                    // Forzar que la imagen sea visible desde el inicio
                    img.style.display = 'block';
                    img.style.visibility = 'visible';
                    img.style.opacity = '1';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    
                    img.onclick = (e) => {
                        e.stopPropagation();
                        showImageModal(newUrl, 'Miniatura Generada');
                    };
                    
                    img.onerror = function() {
                        console.error(`[generateThumbnail] Error al cargar imagen:`, newUrl);
                        const errorPlaceholder = document.createElement('div');
                        errorPlaceholder.className = 'thumbnail-placeholder';
                        errorPlaceholder.id = imgId;
                        errorPlaceholder.textContent = 'Sin imagen';
                        if (this.parentElement) {
                            this.parentElement.replaceChild(errorPlaceholder, this);
                        }
                    };
                    
                    // Insertar la imagen al inicio del contenedor (antes del loading overlay si existe)
                    // Asegurarse de que el loading overlay est√© al final
                    if (loadingOverlayInContainer && container.contains(loadingOverlayInContainer)) {
                        container.insertBefore(img, loadingOverlayInContainer);
                    } else {
                        // Si no hay loading overlay, insertar al inicio
                        if (container.firstChild) {
                            container.insertBefore(img, container.firstChild);
                        } else {
                            container.appendChild(img);
                        }
                    }
                    
                    // Verificar que la imagen se carg√≥ correctamente
                    img.onload = function() {
                        console.log(`[generateThumbnail] Imagen cargada exitosamente:`, newUrl);
                        console.log(`[generateThumbnail] Imagen insertada en:`, container);
                        console.log(`[generateThumbnail] Contenedor padre (thumbnail-cell):`, container.parentElement);
                    };
                    
                    // Actualizar el objeto video en memoria
                    if (allVideos[videoIndex]) {
                        allVideos[videoIndex].generatedThumbnailUrl = newUrl;
                        if (allVideos[videoIndex].fullMetadata) {
                            allVideos[videoIndex].fullMetadata.generatedThumbnail = true;
                            allVideos[videoIndex].fullMetadata.generatedThumbnailPath = data.thumbnailPath || null;
                        }
                    }
                    
                    // Log para depuraci√≥n
                    console.log(`[generateThumbnail] Imagen insertada en contenedor:`, {
                        container: container,
                        imgId: imgId,
                        imgSrc: newUrl,
                        containerChildren: Array.from(container.children).map(c => c.className || c.tagName)
                    });
                    
                    // Actualizar el bot√≥n
                    const buttonText = button.querySelector('span:last-child');
                    const buttonIcon = button.querySelector('span:first-child');
                    if (buttonIcon) buttonIcon.textContent = 'üîÑ';
                    if (buttonText) buttonText.textContent = 'Regenerar';
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Miniatura generada exitosamente';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                } else {
                    throw new Error(data.error || data.message || 'Error al generar miniatura');
                }
            } catch (error) {
                alert(`Error al generar miniatura: ${error.message}`);
                const buttonText = button.querySelector('span:last-child');
                const buttonIcon = button.querySelector('span:first-child');
                if (buttonIcon) buttonIcon.textContent = video.generatedThumbnailUrl ? 'üîÑ' : '‚ú®';
                if (buttonText) buttonText.textContent = video.generatedThumbnailUrl ? 'Regenerar' : 'Generar';
            } finally {
                // Rehabilitar bot√≥n y ocultar loading
                button.disabled = false;
                if (loadingOverlay) {
                    loadingOverlay.classList.remove('active');
                }
            }
        }
        
        async function groupCalls(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Solicitar el nombre del archivo de la otra llamada
            const otherFileName = prompt(`Ingresa el nombre del archivo de la otra llamada para agrupar con:\n\n${video.title}\n\nSi la otra llamada ya tiene un grupo, se usar√° ese grupo. Si no, se generar√° uno nuevo.`);
            
            if (!otherFileName || !otherFileName.trim()) {
                return;
            }
            
            // Buscar la otra llamada en allVideos
            const otherVideo = allVideos.find(v => v.fileName === otherFileName.trim());
            
            if (!otherVideo) {
                alert(`No se encontr√≥ la llamada: ${otherFileName.trim()}`);
                return;
            }
            
            // Determinar el grupo a usar
            let groupId;
            if (video.group && video.group.trim()) {
                groupId = video.group.trim();
            } else if (otherVideo.group && otherVideo.group.trim()) {
                groupId = otherVideo.group.trim();
            } else {
                // Generar un ID aleatorio
                groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            // Confirmar agrupaci√≥n
            const confirmMessage = `¬øAgrupar estas dos llamadas?\n\n1. ${video.title}\n2. ${otherVideo.title}\n\nGrupo: ${groupId}`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            button.innerHTML = '‚è≥';
            button.title = 'Agrupando...';
            
            try {
                // Actualizar metadata de ambas llamadas
                const updatePromises = [];
                
                // Actualizar la llamada actual
                const currentMetadata = video.fullMetadata || {};
                const updatedCurrentMetadata = {
                    ...currentMetadata,
                    group: groupId
                };
                
                updatePromises.push(
                    fetch(`${API_BASE}/api/video/metadata/${encodeURIComponent(video.fileName)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedCurrentMetadata),
                    })
                );
                
                // Actualizar la otra llamada
                const otherMetadata = otherVideo.fullMetadata || {};
                const updatedOtherMetadata = {
                    ...otherMetadata,
                    group: groupId
                };
                
                updatePromises.push(
                    fetch(`${API_BASE}/api/video/metadata/${encodeURIComponent(otherVideo.fileName)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedOtherMetadata),
                    })
                );
                
                const responses = await Promise.all(updatePromises);
                const results = await Promise.all(responses.map(r => r.json()));
                
                // Verificar que ambas actualizaciones fueron exitosas
                const allSuccess = results.every(r => r.success);
                
                if (allSuccess) {
                    // Eliminar similitudes relacionadas de ambas llamadas del archivo
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: video.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: otherVideo.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    // Eliminar relaciones del validationProcess si existe
                    if (validationProcess && validationProcess.similarities) {
                        validationProcess.similarities = validationProcess.similarities.filter(sim => {
                            const source = sim.source || '';
                            const target = sim.target || '';
                            // Eliminar si involucra a cualquiera de las dos llamadas
                            return source !== video.fileName && target !== video.fileName &&
                                   source !== otherVideo.fileName && target !== otherVideo.fileName;
                        });
                    }
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ Llamadas agrupadas exitosamente con grupo: ${groupId}`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Actualizar ambas filas
                    await updateSingleVideoRow(videoIndex, video.fileName);
                    const otherVideoIndex = allVideos.findIndex(v => v.fileName === otherVideo.fileName);
                    if (otherVideoIndex !== -1) {
                        await updateSingleVideoRow(otherVideoIndex, otherVideo.fileName);
                    }
                    
                    // Si el modal de similitudes est√° abierto, recargarlo o cerrarlo
                    const modal = document.getElementById('similarities-summary-modal');
                    if (modal && modal.style.display === 'block') {
                        // Recargar el modal con los datos actualizados
                        showSimilaritiesSummaryModal();
                    }
                } else {
                    throw new Error('Error al actualizar una o ambas llamadas');
                }
            } catch (error) {
                console.error('Error al agrupar llamadas:', error);
                alert(`Error al agrupar llamadas: ${error.message}`);
            } finally {
                // Rehabilitar bot√≥n
                button.disabled = false;
                button.innerHTML = 'üîó';
                button.title = 'Agrupar con otra llamada';
            }
        }
        
        async function deleteCallRecord(videoIndex, video, button, row) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Confirmar eliminaci√≥n
            const confirmMessage = `¬øEst√°s seguro de que deseas eliminar esta llamada?\n\nT√≠tulo: ${video.title}\n\nEsto eliminar√° TODOS los archivos relacionados (JSON, audio, transcripci√≥n, miniaturas, prompts, etc.) y no se puede deshacer.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const iconSpan = button.querySelector('.icon');
            if (iconSpan) {
                iconSpan.textContent = '‚è≥';
            }
            button.title = 'Eliminando...';
            
            try {
                const response = await fetch(`${API_BASE}/api/video/delete/${encodeURIComponent(video.fileName)}`, {
                    method: 'DELETE',
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Eliminar similitudes relacionadas del archivo
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: video.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    if (row) {
                        // Encontrar el wrapper que contiene la fila y el contenedor de detalles
                        const rowWrapper = row.parentElement;
                        
                        // Eliminar el wrapper completo (fila + detalles)
                        if (rowWrapper && rowWrapper.classList.contains('video-row-wrapper')) {
                            rowWrapper.style.transition = 'opacity 0.3s';
                            rowWrapper.style.opacity = '0';
                            
                            setTimeout(() => {
                                rowWrapper.remove();
                            }, 300);
                        } else {
                            // Fallback: eliminar solo la fila si no se encuentra el wrapper
                            row.style.transition = 'opacity 0.3s';
                            row.style.opacity = '0';
                            
                            setTimeout(() => {
                                row.remove();
                            }, 300);
                        }
                    }
                    
                    // Actualizar estad√≠sticas
                    allVideos = allVideos.filter(v => v.fileName !== video.fileName);
                    updateStats();
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ Llamada eliminada exitosamente (${data.deletedCount} archivos)`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    return { success: true };
                } else {
                    throw new Error(data.error || data.message || 'Error al eliminar llamada');
                }
            } catch (error) {
                alert(`Error al eliminar llamada: ${error.message}`);
                button.disabled = false;
                if (iconSpan) {
                    iconSpan.textContent = 'üóëÔ∏è';
                }
                button.title = 'Eliminar';
                return { success: false, error: error.message };
            }
        }
        
        // Funci√≥n auxiliar para extraer el ID del video desde una URL de YouTube
        function extractVideoIdFromUrl(url) {
            if (!url) return null;
            
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /^([a-zA-Z0-9_-]{11})$/,
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            
            return null;
        }
        
        async function reuploadThumbnailToYouTube(videoIndex, video, button) {
            // Obtener el ID del video desde youtubeVideoUrl del metadata
            const metadata = video.fullMetadata || {};
            const youtubeVideoUrl = metadata.youtubeVideoUrl || video.youtubeVideoUrl;
            
            if (!youtubeVideoUrl) {
                alert('Error: El video no tiene una URL de YouTube. Debe subir el video primero.');
                return;
            }
            
            // Extraer el ID del video desde la URL
            const videoId = extractVideoIdFromUrl(youtubeVideoUrl);
            
            if (!videoId) {
                alert('Error: No se pudo extraer el ID del video desde la URL de YouTube.');
                return;
            }
            
            if (!video.generatedThumbnailUrl && !metadata.generatedThumbnailPath) {
                alert('Error: No se encontr√≥ la miniatura generada. Por favor, genere una miniatura primero.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øResubir miniatura a YouTube?\n\nVideo ID: ${videoId}\n\nEsto reemplazar√° la miniatura actual en YouTube.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalText = button.textContent;
            button.textContent = 'Subiendo...';
            
            try {
                // Obtener la ruta de la miniatura desde metadata
                let thumbnailPath = metadata.generatedThumbnailPath || metadata.originalThumbnailPath;
                
                // Si no hay ruta en metadata, construir desde fileName
                if (!thumbnailPath && video.fileName) {
                    thumbnailPath = `storage/calls/${video.fileName}_generated.jpg`;
                }
                
                if (!thumbnailPath) {
                    throw new Error('No se encontr√≥ la ruta de la miniatura');
                }
                
                // Normalizar ruta
                if (thumbnailPath.includes('\\')) {
                    const parts = thumbnailPath.split(/[/\\]/);
                    const storageIndex = parts.findIndex(p => p === 'storage');
                    if (storageIndex >= 0) {
                        thumbnailPath = parts.slice(storageIndex).join('/');
                    }
                }
                
                // Obtener metadataPath
                const metadataPath = video.fileName ? `storage/calls/${video.fileName}.json` : null;
                
                const response = await fetch(`${API_BASE}/api/video/reupload-thumbnail-to-youtube`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        videoId: videoId,
                        thumbnailPath: thumbnailPath,
                        metadataPath: metadataPath,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.innerHTML = `‚úÖ Miniatura resubida exitosamente a YouTube!<br><a href="${data.videoUrl}" target="_blank" style="color: white; text-decoration: underline;">Ver en YouTube</a>`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 8000);
                } else {
                    throw new Error(data.error || data.message || 'Error al resubir miniatura');
                }
            } catch (error) {
                alert(`Error al resubir miniatura a YouTube: ${error.message}`);
            } finally {
                // Rehabilitar bot√≥n
                button.disabled = false;
                button.textContent = originalText;
            }
        }
        
        function toggleOriginalThumbnails(show) {
            const columns = document.querySelectorAll('.thumbnail-original-column');
            columns.forEach(col => {
                if (show) {
                    col.classList.remove('hidden');
                } else {
                    col.classList.add('hidden');
                }
            });
            
            // Guardar preferencia
            localStorage.setItem('showOriginalThumbnails', show.toString());
        }
        
        function applyFilters() {
            const filterNoOriginal = document.getElementById('filterNoOriginalThumbnail').checked;
            const filterNoDescription = document.getElementById('filterNoDescription').checked;
            const searchTerm = document.getElementById('searchFilter').value.trim().toLowerCase();
            let filteredVideos = allVideos;
            
            // Aplicar filtro de b√∫squeda primero
            if (searchTerm) {
                filteredVideos = filteredVideos.filter(video => {
                    // Buscar en t√≠tulo
                    const titleMatch = video.title && video.title.toLowerCase().includes(searchTerm);
                    // Buscar en ID de YouTube
                    const youtubeIdMatch = video.youtubeVideoId && video.youtubeVideoId.toLowerCase().includes(searchTerm);
                    // Buscar en nombre de archivo
                    const fileNameMatch = video.fileName && video.fileName.toLowerCase().includes(searchTerm);
                    // Buscar en descripci√≥n
                    const descriptionMatch = video.description && video.description.toLowerCase().includes(searchTerm);
                    // Buscar en nombre del llamante
                    const nameMatch = video.name && video.name.toLowerCase().includes(searchTerm);
                    
                    return titleMatch || youtubeIdMatch || fileNameMatch || descriptionMatch || nameMatch;
                });
            }
            
            // Aplicar filtros en cascada
            if (filterNoOriginal) {
                // Filtrar solo videos sin miniatura original
                filteredVideos = filteredVideos.filter(video => !video.originalThumbnailUrl);
            }
            
            if (filterNoDescription) {
                // Filtrar solo videos sin descripci√≥n
                filteredVideos = filteredVideos.filter(video => !video.description || video.description.trim() === '' || video.description === 'Sin descripci√≥n');
            }
            
            displayVideos(filteredVideos);
            updateStats(filteredVideos.length);
        }
        
        function updateStats(filteredCount = null) {
            const total = filteredCount !== null ? filteredCount : allVideos.length;
            const totalAll = allVideos.length;
            const statsElement = document.getElementById('stats');
            if (filteredCount !== null && filteredCount !== totalAll) {
                statsElement.textContent = `Mostrando: ${total} de ${totalAll} videos`;
            } else {
                statsElement.textContent = `Total de videos: ${totalAll}`;
            }
        }
        
        /**
         * Actualiza el contador del bot√≥n de subida masiva a Pinecone
         */
        function updateBulkUploadCounter() {
            const bulkCounter = document.getElementById('bulk-upload-counter');
            if (!bulkCounter) return;
            
            const totalCalls = allVideos.length;
            const uploadedCount = allVideos.filter(v => v.pineconeUploaded && !v.isDuplicate).length;
            const percentage = totalCalls > 0 ? ((uploadedCount / totalCalls) * 100).toFixed(2) : '0.00';
            
            bulkCounter.textContent = `${uploadedCount}/${totalCalls} (${percentage}%)`;
        }
        
        // Event listeners para los switches
        document.addEventListener('DOMContentLoaded', () => {
            // Reconectar a todos los procesos activos al cargar la p√°gina
            reconnectToAllProgress();
            
            const showOriginalSwitch = document.getElementById('showOriginalThumbnails');
            if (showOriginalSwitch) {
                showOriginalSwitch.addEventListener('change', (e) => {
                    toggleOriginalThumbnails(e.target.checked);
                });
            }
            
            const filterNoOriginalSwitch = document.getElementById('filterNoOriginalThumbnail');
            if (filterNoOriginalSwitch) {
                filterNoOriginalSwitch.addEventListener('change', () => {
                    applyFilters();
                });
            }
            
            const filterNoDescriptionSwitch = document.getElementById('filterNoDescription');
            if (filterNoDescriptionSwitch) {
                filterNoDescriptionSwitch.addEventListener('change', () => {
                    applyFilters();
                });
            }
            
            const searchFilter = document.getElementById('searchFilter');
            if (searchFilter) {
                // Aplicar filtro mientras se escribe (con un peque√±o delay para mejor rendimiento)
                let searchTimeout;
                searchFilter.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        applyFilters();
                    }, 300); // Esperar 300ms despu√©s de que el usuario deje de escribir
                });
            }
        });
        
        function makeTitleEditable(titleDiv, video, videoIndex) {
            const originalTitle = titleDiv.getAttribute('data-original-title');
            const fileName = titleDiv.getAttribute('data-file-name');
            
            // Crear textarea para editar
            const textarea = document.createElement('textarea');
            textarea.className = 'title-editing';
            textarea.value = originalTitle;
            textarea.style.width = '100%';
            
            // Reemplazar el div con el textarea
            const parent = titleDiv.parentNode;
            parent.replaceChild(textarea, titleDiv);
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            
            // Funci√≥n para cancelar edici√≥n
            const cancelEdit = () => {
                const newDiv = document.createElement('div');
                newDiv.className = 'title title-editable';
                newDiv.textContent = originalTitle;
                newDiv.setAttribute('data-original-title', originalTitle);
                newDiv.setAttribute('data-file-name', fileName);
                newDiv.onclick = (e) => {
                    e.stopPropagation();
                    makeTitleEditable(newDiv, video, videoIndex);
                };
                parent.replaceChild(newDiv, textarea);
            };
            
            // Funci√≥n para guardar
            const saveTitle = async () => {
                const newTitle = textarea.value.trim();
                
                if (newTitle === originalTitle || newTitle === '') {
                    // Cancelar si no hay cambios o est√° vac√≠o
                    cancelEdit();
                    return;
                }
                
                // Deshabilitar textarea mientras se guarda
                textarea.disabled = true;
                textarea.style.opacity = '0.6';
                
                try {
                    const response = await fetch(`${API_BASE}/api/video/update-title/${encodeURIComponent(fileName)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ title: newTitle }),
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        // Mostrar mensaje de √©xito
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                        successMsg.textContent = `‚úÖ T√≠tulo actualizado: "${data.newTitle}" (${data.renamedCount} archivos renombrados)`;
                        document.body.appendChild(successMsg);
                        
                        setTimeout(() => {
                            successMsg.remove();
                        }, 5000);
                        
                        // Recargar la lista de videos para mostrar el nuevo t√≠tulo
                        setTimeout(() => {
                            loadVideos();
                        }, 1000);
                    } else {
                        throw new Error(data.error || data.message || 'Error al actualizar t√≠tulo');
                    }
                } catch (error) {
                    alert(`Error al actualizar t√≠tulo: ${error.message}`);
                    // Restaurar el div original
                    cancelEdit();
                }
            };
            
            // Guardar con Ctrl+Enter o Cmd+Enter, cancelar con Escape
            textarea.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    saveTitle();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
                // Enter solo crea nueva l√≠nea, no guarda
            });
            
            // Guardar al perder el foco
            textarea.addEventListener('blur', () => {
                setTimeout(() => {
                    if (document.activeElement !== textarea) {
                        saveTitle();
                    }
                }, 200);
            });
        }
        
        // Funci√≥n para mostrar imagen en modal
        function showImageModal(imageUrl, title) {
            // Crear modal si no existe
            let modal = document.getElementById('image-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'image-modal';
                modal.className = 'image-modal';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'image-modal-content';
                
                const closeBtn = document.createElement('span');
                closeBtn.className = 'image-modal-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => closeImageModal();
                
                const img = document.createElement('img');
                img.id = 'modal-image';
                img.alt = title;
                
                modalContent.appendChild(closeBtn);
                modalContent.appendChild(img);
                modal.appendChild(modalContent);
                
                // Cerrar al hacer click fuera de la imagen
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        closeImageModal();
                    }
                };
                
                // Cerrar con Escape
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeImageModal();
                    }
                });
                
                document.body.appendChild(modal);
            }
            
            // Mostrar imagen
            const modalImg = document.getElementById('modal-image');
            modalImg.src = imageUrl;
            modalImg.alt = title;
            
            // Mostrar modal
            modal.classList.add('active');
            document.body.style.overflow = 'hidden'; // Prevenir scroll del body
        }
        
        function closeImageModal() {
            const modal = document.getElementById('image-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = ''; // Restaurar scroll
            }
        }
        
        async function showThumbnailPromptModal(videoIndex, video) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Crear o obtener el modal
            let modal = document.getElementById('prompt-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'prompt-modal';
                modal.className = 'prompt-modal';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'prompt-modal-content';
                
                const header = document.createElement('div');
                header.className = 'prompt-modal-header';
                
                const title = document.createElement('div');
                title.className = 'prompt-modal-title';
                title.textContent = 'Prompt de Generaci√≥n de Miniatura';
                
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'prompt-modal-actions';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'prompt-copy-btn';
                copyBtn.id = 'prompt-copy-btn';
                copyBtn.innerHTML = 'üìã Copiar';
                copyBtn.onclick = () => copyPromptToClipboard();
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'prompt-modal-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = closeThumbnailPromptModal;
                
                actionsContainer.appendChild(copyBtn);
                actionsContainer.appendChild(closeBtn);
                
                header.appendChild(title);
                header.appendChild(actionsContainer);
                
                const promptContent = document.createElement('div');
                promptContent.className = 'prompt-content';
                promptContent.id = 'prompt-content';
                
                modalContent.appendChild(header);
                modalContent.appendChild(promptContent);
                modal.appendChild(modalContent);
                
                // Cerrar al hacer click fuera del contenido
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        closeThumbnailPromptModal();
                    }
                };
                
                // Cerrar con Escape
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeThumbnailPromptModal();
                    }
                });
                
                document.body.appendChild(modal);
            }
            
            // Mostrar modal con estado de carga
            const promptContent = document.getElementById('prompt-content');
            promptContent.textContent = 'Cargando prompt...';
            promptContent.classList.remove('prompt-empty');
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            try {
                // Obtener el prompt completo desde el endpoint
                const response = await fetch(`${API_BASE}/api/video/thumbnail-prompt/${encodeURIComponent(video.fileName)}`);
                const data = await response.json();
                
                if (response.ok && data.success && data.prompt) {
                    promptContent.textContent = data.prompt;
                    promptContent.classList.remove('prompt-empty');
                } else {
                    // Si no hay summary, mostrar mensaje m√°s claro
                    const metadata = video.fullMetadata || {};
                    if (!metadata.summary || metadata.summary.trim() === '') {
                        promptContent.textContent = 'No se puede generar el prompt porque falta el resumen (summary) en el metadata. Por favor, procese la llamada primero para generar el resumen.';
                    } else {
                        promptContent.textContent = `Error al generar el prompt: ${data.error || data.message || 'No se pudo obtener el prompt'}`;
                    }
                    promptContent.classList.add('prompt-empty');
                }
            } catch (error) {
                const metadata = video.fullMetadata || {};
                if (!metadata.summary || metadata.summary.trim() === '') {
                    promptContent.textContent = 'No se puede generar el prompt porque falta el resumen (summary) en el metadata. Por favor, procese la llamada primero para generar el resumen.';
                } else {
                    promptContent.textContent = `Error al cargar el prompt: ${error.message}`;
                }
                promptContent.classList.add('prompt-empty');
            }
        }
        
        function showSimilarCallsModal(similarCalls, isDuplicate, duplicateOf, message, currentCallTitle = null, currentCallDescription = null) {
            console.log('showSimilarCallsModal llamado con:', {
                similarCalls: similarCalls,
                similarCallsLength: similarCalls?.length || 0,
                isDuplicate: isDuplicate,
                duplicateOf: duplicateOf,
                message: message,
                currentCallTitle: currentCallTitle
            });
            
            // Crear o obtener el modal
            let modal = document.getElementById('similar-calls-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'similar-calls-modal';
                modal.className = 'metadata-modal'; // Reutilizar estilos del modal de metadata
                
                const modalContent = document.createElement('div');
                modalContent.className = 'metadata-modal-content';
                modalContent.style.maxWidth = '600px';
                
                const header = document.createElement('div');
                header.className = 'metadata-modal-header';
                
                const title = document.createElement('div');
                title.className = 'metadata-modal-title';
                title.id = 'similar-calls-modal-title';
                title.textContent = 'Llamadas Similares';
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'metadata-modal-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => {
                    modal.classList.remove('active');
                };
                
                header.appendChild(title);
                header.appendChild(closeBtn);
                
                // Crear contenedor para la descripci√≥n de la llamada actual (fuera del √°rea de desplazamiento)
                const descriptionContainer = document.createElement('div');
                descriptionContainer.id = 'similar-calls-description';
                descriptionContainer.style.cssText = 'padding: 0 20px; margin-bottom: 10px;';
                
                const content = document.createElement('div');
                content.id = 'similar-calls-content';
                content.style.cssText = 'max-height: 500px; overflow-y: auto; padding: 10px 0;';
                
                const actions = document.createElement('div');
                actions.className = 'metadata-modal-actions';
                
                const closeActionBtn = document.createElement('button');
                closeActionBtn.className = 'metadata-cancel-btn';
                closeActionBtn.textContent = 'Cerrar';
                closeActionBtn.onclick = () => {
                    modal.classList.remove('active');
                };
                
                actions.appendChild(closeActionBtn);
                
                modalContent.appendChild(header);
                modalContent.appendChild(descriptionContainer);
                modalContent.appendChild(content);
                modalContent.appendChild(actions);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Cerrar modal al hacer click fuera
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('active');
                    }
                };
            }
            
            // Actualizar t√≠tulo del modal con el t√≠tulo de la llamada actual
            const titleElement = document.getElementById('similar-calls-modal-title');
            if (titleElement) {
                if (currentCallTitle) {
                    titleElement.textContent = `Llamadas Similares a "${currentCallTitle}"`;
                } else {
                    titleElement.textContent = 'Llamadas Similares';
                }
            }
            
            // Actualizar descripci√≥n de la llamada actual (fuera del √°rea de desplazamiento)
            const descriptionContainer = document.getElementById('similar-calls-description');
            if (descriptionContainer) {
                descriptionContainer.innerHTML = '';
                if (currentCallDescription) {
                    const descriptionDiv = document.createElement('div');
                    descriptionDiv.style.cssText = 'padding: 10px; background: #f8f9fa; border-left: 3px solid #2196F3; border-radius: 4px; font-size: 13px; color: #555; line-height: 1.5;';
                    descriptionDiv.textContent = currentCallDescription;
                    descriptionContainer.appendChild(descriptionDiv);
                }
            }
            
            // Actualizar contenido
            const content = document.getElementById('similar-calls-content');
            content.innerHTML = '';
            
            // Mostrar mensaje principal
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = 'margin-bottom: 20px; padding: 10px; background: #f5f5f5; border-radius: 6px;';
            if (isDuplicate) {
                messageDiv.style.background = '#fff3cd';
                messageDiv.style.border = '1px solid #ffc107';
            } else {
                messageDiv.style.background = '#d4edda';
                messageDiv.style.border = '1px solid #28a745';
            }
            messageDiv.textContent = message;
            content.appendChild(messageDiv);
            
            // Mostrar lista de llamadas similares
            if (similarCalls.length > 0) {
                const listTitle = document.createElement('div');
                listTitle.style.cssText = 'font-weight: 600; margin-bottom: 10px; font-size: 14px;';
                listTitle.textContent = `Llamadas similares encontradas (${similarCalls.length}):`;
                content.appendChild(listTitle);
                
                const list = document.createElement('div');
                list.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
                
                similarCalls.forEach((call, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'padding: 12px; background: white; border: 1px solid #ddd; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;';
                    
                    const leftDiv = document.createElement('div');
                    leftDiv.style.cssText = 'flex: 1;';
                    
                    const titleSpan = document.createElement('div');
                    titleSpan.style.cssText = 'font-weight: 600; margin-bottom: 4px;';
                    titleSpan.textContent = call.title || call.fileName || 'Sin t√≠tulo';
                    
                    const fileNameSpan = document.createElement('div');
                    fileNameSpan.style.cssText = 'font-size: 12px; color: #666; font-family: monospace; margin-bottom: 6px;';
                    fileNameSpan.textContent = call.fileName || call.callId || 'N/A';
                    
                    leftDiv.appendChild(titleSpan);
                    leftDiv.appendChild(fileNameSpan);
                    
                    // Agregar descripci√≥n si est√° disponible
                    if (call.description) {
                        const descriptionSpan = document.createElement('div');
                        descriptionSpan.style.cssText = 'font-size: 12px; color: #777; margin-top: 6px; line-height: 1.4; font-style: italic;';
                        descriptionSpan.textContent = call.description;
                        leftDiv.appendChild(descriptionSpan);
                    }
                    
                    const rightDiv = document.createElement('div');
                    rightDiv.style.cssText = 'margin-left: 15px; text-align: right;';
                    
                    const similarityDiv = document.createElement('div');
                    similarityDiv.style.cssText = 'font-size: 18px; font-weight: 700; color: #2196F3;';
                    // Mostrar con 4 decimales
                    const similarityValue = typeof call.similarity === 'number' 
                      ? call.similarity.toFixed(4) 
                      : parseFloat(call.similarity || 0).toFixed(4);
                    similarityDiv.textContent = `${similarityValue}%`;
                    
                    const labelDiv = document.createElement('div');
                    labelDiv.style.cssText = 'font-size: 11px; color: #666; margin-top: 2px;';
                    labelDiv.textContent = 'Similitud';
                    
                    rightDiv.appendChild(similarityDiv);
                    rightDiv.appendChild(labelDiv);
                    
                    item.appendChild(leftDiv);
                    item.appendChild(rightDiv);
                    list.appendChild(item);
                });
                
                content.appendChild(list);
            } else {
                // Mostrar mensaje cuando no hay llamadas similares
                const noSimilarDiv = document.createElement('div');
                noSimilarDiv.style.cssText = 'padding: 15px; background: #f0f0f0; border-radius: 6px; text-align: center; color: #666;';
                noSimilarDiv.textContent = 'No se encontraron llamadas similares.';
                content.appendChild(noSimilarDiv);
            }
            
            // Mostrar modal
            modal.classList.add('active');
        }
        
        function closeThumbnailPromptModal() {
            const modal = document.getElementById('prompt-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = ''; // Restaurar scroll
            }
        }
        
        async function copyPromptToClipboard() {
            const promptContent = document.getElementById('prompt-content');
            if (!promptContent) {
                return;
            }
            
            const promptText = promptContent.textContent;
            if (!promptText || promptText.trim() === '' || promptText === 'Cargando prompt...') {
                alert('No hay prompt disponible para copiar');
                return;
            }
            
            try {
                // Usar la Clipboard API moderna
                await navigator.clipboard.writeText(promptText);
                
                // Mostrar feedback visual
                const copyBtn = document.getElementById('prompt-copy-btn');
                if (copyBtn) {
                    const originalText = copyBtn.innerHTML;
                    copyBtn.innerHTML = '‚úÖ Copiado!';
                    copyBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        copyBtn.innerHTML = originalText;
                        copyBtn.classList.remove('copied');
                    }, 2000);
                }
            } catch (error) {
                // Fallback para navegadores que no soportan Clipboard API
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = promptText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    // Mostrar feedback visual
                    const copyBtn = document.getElementById('prompt-copy-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '‚úÖ Copiado!';
                        copyBtn.classList.add('copied');
                        
                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    }
                } catch (fallbackError) {
                    alert('No se pudo copiar el prompt al portapapeles. Por favor, selecciona el texto manualmente.');
                }
            }
        }
        
        async function regenerateTitleRecord(videoIndex, video, button, row) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øEst√°s seguro de que deseas regenerar el t√≠tulo de esta llamada?\n\nT√≠tulo actual: ${video.title}\n\nEsto generar√° un nuevo t√≠tulo usando IA y renombrar√° todos los archivos relacionados.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            button.textContent = 'Generando...';
            
            try {
                const response = await fetch(`${API_BASE}/api/video/regenerate-title/${encodeURIComponent(video.fileName)}`, {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #2196F3; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ T√≠tulo regenerado: "${data.newTitle}" (${data.renamedCount} archivos renombrados)`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 5000);
                    
                    // Recargar la lista de videos para mostrar el nuevo t√≠tulo
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                } else {
                    throw new Error(data.error || data.message || 'Error al regenerar t√≠tulo');
                }
            } catch (error) {
                alert(`Error al regenerar t√≠tulo: ${error.message}`);
                button.disabled = false;
                button.textContent = '‚úèÔ∏è Regenerar T√≠tulo';
            }
        }
        
        async function editMetadataRecord(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            if (!video.fullMetadata) {
                alert('Error: No se encontr√≥ el metadata completo del video');
                return;
            }
            
            // Guardar referencia al videoIndex y video para actualizar despu√©s
            const currentVideoIndex = videoIndex;
            const currentVideo = video;
            
            // Funci√≥n para reiniciar el bot√≥n Guardar (disponible siempre)
            const resetSaveButton = () => {
                const saveBtn = document.querySelector('.metadata-save-btn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Guardar';
                }
            };
            
            // Crear el modal si no existe
            let modal = document.getElementById('metadata-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'metadata-modal';
                modal.className = 'metadata-modal';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'metadata-modal-content';
                
                const header = document.createElement('div');
                header.className = 'metadata-modal-header';
                
                const title = document.createElement('div');
                title.className = 'metadata-modal-title';
                title.textContent = 'Editar Metadata JSON';
                
                const fileName = document.createElement('div');
                fileName.className = 'metadata-modal-filename';
                fileName.id = 'metadata-modal-filename';
                
                const titleContainer = document.createElement('div');
                titleContainer.style.display = 'flex';
                titleContainer.style.flexDirection = 'column';
                titleContainer.appendChild(title);
                titleContainer.appendChild(fileName);
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'metadata-modal-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => {
                    resetSaveButton();
                    modal.classList.remove('active');
                };
                
                header.appendChild(titleContainer);
                header.appendChild(closeBtn);
                
                const editorContainer = document.createElement('div');
                editorContainer.className = 'metadata-editor-container';
                
                const editor = document.createElement('textarea');
                editor.className = 'metadata-editor';
                editor.id = 'metadata-editor';
                editor.spellcheck = false;
                
                editorContainer.appendChild(editor);
                
                const actions = document.createElement('div');
                actions.className = 'metadata-modal-actions';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'metadata-cancel-btn';
                cancelBtn.textContent = 'Cancelar';
                cancelBtn.onclick = () => {
                    resetSaveButton();
                    modal.classList.remove('active');
                };
                
                const saveBtn = document.createElement('button');
                saveBtn.className = 'metadata-save-btn';
                saveBtn.textContent = 'Guardar';
                saveBtn.onclick = async () => {
                    try {
                        const jsonText = editor.value;
                        // Validar JSON
                        const updatedMetadata = JSON.parse(jsonText);
                        
                        saveBtn.disabled = true;
                        saveBtn.textContent = 'Guardando...';
                        
                        const response = await fetch(`${API_BASE}/api/video/metadata/${encodeURIComponent(currentVideo.fileName)}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: jsonText,
                        });
                        
                        const data = await response.json();
                        
                        if (response.ok && data.success) {
                            resetSaveButton();
                            modal.classList.remove('active');
                            
                            // Mostrar mensaje de √©xito
                            const successMsg = document.createElement('div');
                            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                            successMsg.textContent = '‚úÖ Metadata guardado exitosamente';
                            document.body.appendChild(successMsg);
                            
                            setTimeout(() => {
                                successMsg.remove();
                            }, 3000);
                            
                            // Actualizar solo el registro modificado
                            setTimeout(() => {
                                updateSingleVideoRow(currentVideoIndex, currentVideo.fileName);
                            }, 500);
                        } else {
                            throw new Error(data.error || data.message || 'Error al guardar metadata');
                        }
                    } catch (error) {
                        if (error instanceof SyntaxError) {
                            alert(`Error: JSON inv√°lido. ${error.message}`);
                        } else {
                            alert(`Error al guardar metadata: ${error.message}`);
                        }
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'Guardar';
                    }
                };
                
                actions.appendChild(cancelBtn);
                actions.appendChild(saveBtn);
                
                modalContent.appendChild(header);
                modalContent.appendChild(editorContainer);
                modalContent.appendChild(actions);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Cerrar modal al hacer click fuera
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        resetSaveButton();
                        modal.classList.remove('active');
                    }
                };
            }
            
            // Actualizar el nombre del archivo en el modal
            const fileNameElement = document.getElementById('metadata-modal-filename');
            if (fileNameElement) {
                fileNameElement.textContent = `${video.fileName}.json`;
            }
            
            // Cargar el metadata en el editor
            const editor = document.getElementById('metadata-editor');
            const metadataJson = JSON.stringify(video.fullMetadata, null, 2);
            editor.value = metadataJson;
            
            // Reiniciar el bot√≥n Guardar antes de mostrar el modal
            resetSaveButton();
            
            // Mostrar el modal
            modal.classList.add('active');
            editor.focus();
            
            // Seleccionar todo el texto para facilitar la edici√≥n
            editor.select();
        }
        
        async function resubmitEmbeddingToPinecone(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Verificar que est√© subida a Pinecone
            if (!video.pineconeUploaded) {
                alert('Error: Esta llamada no est√° subida a Pinecone. Use el bot√≥n "Subir embedding" primero.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øRe-subir el embedding de esta llamada a Pinecone?\n\nT√≠tulo: ${video.title}\n\nEsto generar√° un nuevo embedding desde cero con el formato actualizado (nombre, edad, descripci√≥n, resumen) y actualizar√° el embedding existente en Pinecone, pisando el anterior.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalText = button.querySelector('span:last-child').textContent;
            const originalIcon = button.querySelector('span:first-child').textContent;
            button.querySelector('span:last-child').textContent = 'Re-subiendo...';
            button.querySelector('span:first-child').textContent = '‚è≥';
            
            try {
                const response = await fetch(`${API_BASE}/api/calls/resubmit-embedding`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: video.fileName,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #FF9800; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Embedding re-subido exitosamente a Pinecone';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Actualizar solo el registro espec√≠fico
                    setTimeout(() => {
                        updateSingleVideoRow(videoIndex, video.fileName);
                    }, 500);
                } else {
                    throw new Error(data.error || data.message || 'Error al re-subir embedding a Pinecone');
                }
            } catch (error) {
                alert(`Error al re-subir embedding a Pinecone: ${error.message}`);
                // Restaurar bot√≥n
                button.disabled = false;
                button.querySelector('span:last-child').textContent = originalText;
                button.querySelector('span:first-child').textContent = originalIcon;
            }
        }
        
        async function revalidateCallInPinecone(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Verificar que est√© subida a Pinecone
            if (!video.pineconeUploaded) {
                alert('Error: Esta llamada no est√° subida a Pinecone. Use el bot√≥n "Subir embedding" primero.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øValidar similitudes de esta llamada?\n\nT√≠tulo: ${video.title}\n\nEsto usar√° el embedding existente en el archivo .emb para buscar llamadas similares, duplicados y relacionadas en Pinecone.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalText = button.querySelector('span:last-child').textContent;
            const originalIcon = button.querySelector('span:first-child').textContent;
            button.querySelector('span:last-child').textContent = 'Validando...';
            button.querySelector('span:first-child').textContent = '‚è≥';
            
            try {
                const response = await fetch(`${API_BASE}/api/calls/revalidate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: video.fileName,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar modal con el resultado del proceso
                    const similarCalls = data.similarCalls || [];
                    const duplicateOfArray = Array.isArray(data.duplicateOf) ? data.duplicateOf : (data.duplicateOf ? [data.duplicateOf] : []);
                    console.log('Re-validaci√≥n completada:', {
                        similarCalls: similarCalls,
                        similarCallsLength: similarCalls.length,
                        relatedCalls: data.relatedCalls,
                        relatedCallsLength: data.relatedCalls?.length || 0,
                        duplicateOf: duplicateOfArray,
                        message: data.message
                    });
                    showSimilarCallsModal(similarCalls, data.isDuplicate, duplicateOfArray, data.message, video.title, data.currentCallDescription);
                    
                    // Actualizar el objeto video en allVideos
                    if (allVideos[videoIndex]) {
                        allVideos[videoIndex].isDuplicate = data.isDuplicate;
                        allVideos[videoIndex].duplicateOf = duplicateOfArray;
                        allVideos[videoIndex].relatedCalls = data.relatedCalls || [];
                    }
                    
                    // Recargar la p√°gina para mostrar los cambios actualizados
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                } else {
                    throw new Error(data.error || data.message || 'Error al re-validar en Pinecone');
                }
            } catch (error) {
                alert(`Error al re-validar en Pinecone: ${error.message}`);
                // Restaurar bot√≥n
                button.disabled = false;
                button.querySelector('span:last-child').textContent = originalText;
                button.querySelector('span:first-child').textContent = originalIcon;
            }
        }
        
        async function uploadToPinecone(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Verificar si ya est√° subido
            if (video.pineconeUploaded && !video.isDuplicate) {
                const relatedInfo = video.relatedCalls && video.relatedCalls.length > 0 
                    ? `\n\nLlamadas relacionadas: ${video.relatedCalls.length}`
                    : '';
                alert(`Esta llamada ya est√° subida a Pinecone.${relatedInfo}\n\nUse el bot√≥n "Validar similitudes" para buscar llamadas similares.`);
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øSubir embedding de esta llamada a Pinecone?\n\nT√≠tulo: ${video.title}\n\nEsto generar√° un embedding con el formato (nombre, edad, descripci√≥n, resumen) y lo subir√° a Pinecone.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalText = button.querySelector('.text').textContent;
            const originalIcon = button.querySelector('.icon').textContent;
            button.querySelector('.text').textContent = 'Subiendo...';
            button.querySelector('.icon').textContent = '‚è≥';
            
            try {
                const response = await fetch(`${API_BASE}/api/calls/upload-to-pinecone`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: video.fileName,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Embedding subido exitosamente a Pinecone';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Actualizar solo el registro espec√≠fico
                    setTimeout(() => {
                        updateSingleVideoRow(videoIndex, video.fileName);
                    }, 500);
                } else {
                    throw new Error(data.error || data.message || 'Error al subir a Pinecone');
                }
            } catch (error) {
                alert(`Error al subir a Pinecone: ${error.message}`);
                // Restaurar bot√≥n
                button.disabled = false;
                button.querySelector('.text').textContent = originalText;
                button.querySelector('.icon').textContent = originalIcon;
            }
        }
        
        /**
         * Sube todas las llamadas a Pinecone en secuencia
         */
        async function bulkUploadToPinecone() {
            // Obtener todas las llamadas que no est√°n subidas a Pinecone
            const callsToUpload = allVideos.filter(video => 
                !video.pineconeUploaded && !video.isDuplicate && video.fileName
            );
            
            if (callsToUpload.length === 0) {
                alert('No hay llamadas pendientes para subir a Pinecone.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øSubir ${callsToUpload.length} llamada(s) a Pinecone en secuencia?\n\nEsto puede tardar varios minutos. El proceso se ejecutar√° de forma sincr√≥nica, una llamada a la vez.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Obtener elementos del bot√≥n
            const bulkBtn = document.getElementById('bulk-upload-pinecone-btn');
            const bulkIcon = document.getElementById('bulk-upload-icon');
            const bulkText = document.getElementById('bulk-upload-text');
            const bulkCounter = document.getElementById('bulk-upload-counter');
            
            // Deshabilitar bot√≥n y mostrar loading
            bulkBtn.disabled = true;
            bulkIcon.textContent = '‚è≥';
            bulkText.textContent = 'Subiendo...';
            
            const totalCalls = allVideos.length;
            let uploadedCount = allVideos.filter(v => v.pineconeUploaded && !v.isDuplicate).length;
            let processedCount = 0;
            let successCount = 0;
            let errorCount = 0;
            
            // Funci√≥n para actualizar el contador
            const updateCounter = () => {
                const percentage = totalCalls > 0 ? ((uploadedCount / totalCalls) * 100).toFixed(2) : '0.00';
                bulkCounter.textContent = `${uploadedCount}/${totalCalls} (${percentage}%)`;
            };
            
            // Actualizar contador inicial
            updateCounter();
            
            // Procesar cada llamada en secuencia
            for (let i = 0; i < callsToUpload.length; i++) {
                const video = callsToUpload[i];
                const videoIndex = allVideos.findIndex(v => v.fileName === video.fileName);
                
                try {
                    const response = await fetch(`${API_BASE}/api/calls/upload-to-pinecone`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fileName: video.fileName,
                        }),
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        successCount++;
                        uploadedCount++;
                        
                        // Actualizar el video en allVideos
                        if (videoIndex >= 0) {
                            allVideos[videoIndex].pineconeUploaded = true;
                            allVideos[videoIndex].pineconeId = data.pineconeId;
                        }
                        
                        // Actualizar contador
                        updateCounter();
                    } else {
                        errorCount++;
                        console.error(`Error al subir ${video.fileName}:`, data.error || data.message);
                    }
                } catch (error) {
                    errorCount++;
                    console.error(`Error al subir ${video.fileName}:`, error.message);
                }
                
                processedCount++;
            }
            
            // Restaurar bot√≥n
            bulkBtn.disabled = false;
            bulkIcon.textContent = 'üìä';
            bulkText.textContent = 'Subir todas a Pinecone';
            
            // Actualizar contador final
            updateCounter();
            
            // Mostrar mensaje de resumen
            const summaryMsg = document.createElement('div');
            summaryMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000; max-width: 400px;';
            summaryMsg.innerHTML = `
                <strong>‚úÖ Proceso completado</strong><br>
                Exitosas: ${successCount}<br>
                Errores: ${errorCount}<br>
                Total procesadas: ${processedCount}<br>
                <small>Recargando lista...</small>
            `;
            document.body.appendChild(summaryMsg);
            
            setTimeout(() => {
                summaryMsg.remove();
            }, 5000);
            
            // Recargar la lista de videos para actualizar el estado
            setTimeout(() => {
                loadVideos();
            }, 1000);
        }
        
        // Variable global para controlar el proceso de validaci√≥n
        let validationProcess = null;
        let validationAborted = false;
        
        async function bulkValidateSimilarities() {
            // Si ya hay un proceso en curso, detenerlo y mostrar resumen
            if (validationProcess && !validationAborted) {
                validationAborted = true;
                // El proceso se detendr√° en la pr√≥xima iteraci√≥n
                return;
            }
            
            // Obtener todas las llamadas que est√°n subidas a Pinecone (incluyendo duplicados)
            const callsToValidate = allVideos.filter(video => 
                video.pineconeUploaded && video.fileName
            );
            
            if (callsToValidate.length === 0) {
                alert('No hay llamadas subidas a Pinecone para validar similitudes.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øValidar similitudes de ${callsToValidate.length} llamada(s)?\n\nEsto puede tardar varios minutos. El proceso se ejecutar√° con un m√°ximo de 5 validaciones simult√°neas. Cuando una termine, comenzar√° la siguiente autom√°ticamente.\n\nPuedes presionar el bot√≥n nuevamente para detener el proceso y ver un resumen.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Resetear variables
            validationAborted = false;
            validationProcess = {
                total: callsToValidate.length,
                processed: 0,
                success: 0,
                errors: 0,
                similarities: []
            };
            
            // Obtener elementos del bot√≥n
            const validateBtn = document.getElementById('bulk-validate-similarities-btn');
            const validateIcon = document.getElementById('bulk-validate-icon');
            const validateText = document.getElementById('bulk-validate-text');
            const validateCounter = document.getElementById('bulk-validate-counter');
            
            // Deshabilitar bot√≥n y mostrar loading
            validateBtn.disabled = false; // Permitir presionar para detener
            validateIcon.textContent = '‚è≥';
            validateText.textContent = 'Validando... (Presiona para detener)';
            
            // Funci√≥n para actualizar el contador
            const updateCounter = () => {
                const percentage = validationProcess.total > 0 
                    ? ((validationProcess.processed / validationProcess.total) * 100).toFixed(2) 
                    : '0.00';
                validateCounter.textContent = `${validationProcess.processed}/${validationProcess.total} (${percentage}%)`;
            };
            
            // Actualizar contador inicial
            updateCounter();
            
            // Funci√≥n auxiliar para procesar una llamada individual
            const processSingleCall = async (video) => {
                try {
                    const response = await fetch(`${API_BASE}/api/calls/revalidate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fileName: video.fileName,
                        }),
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        // Recopilar similitudes
                        const similarCalls = data.similarCalls || [];
                        const relatedCalls = data.relatedCalls || []; // Array de strings (nombres de archivo)
                        const duplicateOf = data.duplicateOf; // Array de strings (nombres de archivo)
                        
                        // Crear un Set de archivos duplicados para evitar duplicaci√≥n
                        const duplicateSet = new Set();
                        if (duplicateOf) {
                            const duplicateArray = Array.isArray(duplicateOf) ? duplicateOf : [duplicateOf];
                            duplicateArray.forEach(dupFileName => {
                                duplicateSet.add(dupFileName);
                            });
                        }
                        
                        // Crear un Set de archivos relacionados para evitar duplicaci√≥n
                        const relatedSet = new Set(relatedCalls);
                        
                        // Crear un mapa de similarCalls por fileName para b√∫squeda r√°pida
                        const similarCallsMap = new Map();
                        similarCalls.forEach(similar => {
                            const fileName = similar.fileName || similar.id;
                            if (fileName) {
                                similarCallsMap.set(fileName, similar);
                            }
                        });
                        
                        // Funci√≥n auxiliar para obtener t√≠tulo desde similarCalls o allVideos
                        const getTitleForFileName = (fileName) => {
                            // Primero buscar en similarCalls
                            const similarCall = similarCallsMap.get(fileName);
                            if (similarCall && similarCall.title) {
                                return similarCall.title;
                            }
                            // Si no est√° en similarCalls, buscar en allVideos
                            const foundVideo = allVideos.find(v => v.fileName === fileName);
                            if (foundVideo && foundVideo.title) {
                                return foundVideo.title;
                            }
                            return null;
                        };
                        
                        // Funci√≥n auxiliar para obtener similitud desde similarCalls
                        const getSimilarityForFileName = (fileName) => {
                            const similarCall = similarCallsMap.get(fileName);
                            if (similarCall && similarCall.similarity) {
                                return similarCall.similarity;
                            }
                            return null;
                        };
                        
                        const similarities = [];
                        
                        // PRIMERO: Agregar duplicados (tienen prioridad)
                        if (duplicateOf) {
                            const duplicateArray = Array.isArray(duplicateOf) ? duplicateOf : [duplicateOf];
                            duplicateArray.forEach(dupFileName => {
                                const title = getTitleForFileName(dupFileName);
                                const similarity = getSimilarityForFileName(dupFileName) || 100.0; // Default para duplicados
                                
                                similarities.push({
                                    source: video.fileName,
                                    sourceTitle: video.title,
                                    target: dupFileName,
                                    targetTitle: title || 'N/A',
                                    similarity: similarity,
                                    type: 'duplicate'
                                });
                            });
                        }
                        
                        // SEGUNDO: Agregar llamadas relacionadas (excluyendo duplicados)
                        relatedCalls.forEach(relatedFileName => {
                            // Solo agregar si no es un duplicado
                            if (!duplicateSet.has(relatedFileName)) {
                                const title = getTitleForFileName(relatedFileName);
                                const similarity = getSimilarityForFileName(relatedFileName) || 90.0; // Default para relacionadas
                                
                                similarities.push({
                                    source: video.fileName,
                                    sourceTitle: video.title,
                                    target: relatedFileName,
                                    targetTitle: title || 'N/A',
                                    similarity: similarity,
                                    type: 'related'
                                });
                            }
                        });
                        
                        // TERCERO: Agregar similares (excluyendo duplicados y relacionadas)
                        similarCalls.forEach(similar => {
                            const fileName = similar.fileName || similar.id;
                            // Solo agregar si no es duplicado ni relacionada
                            if (fileName && !duplicateSet.has(fileName) && !relatedSet.has(fileName)) {
                                similarities.push({
                                    source: video.fileName,
                                    sourceTitle: video.title,
                                    target: fileName,
                                    targetTitle: similar.title || getTitleForFileName(fileName) || 'N/A',
                                    similarity: similar.similarity || 0,
                                    type: 'similar'
                                });
                            }
                        });
                        
                        return { success: true, similarities };
                    } else {
                        return { success: false, error: data.error || data.message };
                    }
                } catch (error) {
                    return { success: false, error: error.message };
                }
            };
            
            // Sistema de cola con m√°ximo de 10 validaciones simult√°neas
            const MAX_CONCURRENT = 10;
            let currentIndex = 0;
            const activePromises = [];
            
            // Funci√≥n para procesar el siguiente elemento de la cola
            const processNext = async () => {
                // Verificar si se debe detener o si ya no hay m√°s elementos
                if (validationAborted || currentIndex >= callsToValidate.length) {
                    return;
                }
                
                // Obtener el siguiente video a procesar
                const video = callsToValidate[currentIndex];
                currentIndex++;
                
                // Crear una promesa que procesa la llamada
                const promise = processSingleCall(video).then((result) => {
                    // Procesar resultado
                    if (result.success) {
                        validationProcess.success++;
                        // Agregar similitudes al array global
                        validationProcess.similarities.push(...result.similarities);
                    } else {
                        validationProcess.errors++;
                        console.error(`Error al validar ${video.fileName}:`, result.error);
                    }
                    validationProcess.processed++;
                    updateCounter();
                    
                    return result;
                }).catch((error) => {
                    // Manejar errores
                    validationProcess.errors++;
                    validationProcess.processed++;
                    console.error(`Error al validar ${video.fileName}:`, error);
                    updateCounter();
                    
                    return { success: false, error: error.message };
                }).finally(() => {
                    // Remover esta promesa del array de activas
                    const index = activePromises.indexOf(promise);
                    if (index > -1) {
                        activePromises.splice(index, 1);
                    }
                    
                    // Inmediatamente procesar la siguiente llamada si hay m√°s
                    if (!validationAborted && currentIndex < callsToValidate.length) {
                        processNext();
                    }
                });
                
                // Agregar la promesa al array de activas
                activePromises.push(promise);
            };
            
            // Iniciar las primeras MAX_CONCURRENT validaciones
            for (let i = 0; i < Math.min(MAX_CONCURRENT, callsToValidate.length); i++) {
                if (!validationAborted) {
                    processNext();
                }
            }
            
            // Esperar a que todas las promesas terminen
            // El bucle espera hasta que no haya m√°s promesas activas y no haya m√°s elementos por procesar
            while ((activePromises.length > 0 || currentIndex < callsToValidate.length) && !validationAborted) {
                if (activePromises.length > 0) {
                    // Esperar a que al menos una promesa termine
                    await Promise.race(activePromises);
                } else if (currentIndex < callsToValidate.length) {
                    // Si no hay promesas activas pero a√∫n hay elementos, esperar un momento
                    // (esto no deber√≠a pasar normalmente, pero es una medida de seguridad)
                    await new Promise(resolve => setTimeout(resolve, 50));
                } else {
                    // Si no hay promesas activas y no hay m√°s elementos, salir del bucle
                    break;
                }
            }
            
            // Si se detuvo, mostrar modal con resumen
            if (validationAborted || validationProcess.processed < validationProcess.total) {
                showSimilaritiesSummaryModal();
            } else {
                // Proceso completado normalmente
                // Guardar resultados en el backend
                try {
                    await fetch(`${API_BASE}/api/calls/save-similarities`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            similarities: validationProcess.similarities,
                        }),
                    });
                } catch (error) {
                    console.error('Error al guardar similitudes:', error);
                }
                
                // Mostrar modal con resumen
                showSimilaritiesSummaryModal();
            }
            
            // Restaurar bot√≥n
            validateBtn.disabled = false;
            validateIcon.textContent = 'üîç';
            validateText.textContent = 'Validar similitudes';
            validateCounter.textContent = '';
            
            // Limpiar proceso
            validationProcess = null;
            validationAborted = false;
        }
        
        async function loadSimilaritiesFromFile() {
            try {
                const response = await fetch(`${API_BASE}/api/calls/get-similarities`);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Crear un objeto temporal similar a validationProcess para usar la misma funci√≥n
                    const tempProcess = {
                        similarities: data.similarities || [],
                        processed: data.totalRelations || 0,
                        total: data.totalRelations || 0,
                        success: data.totalRelations || 0,
                        errors: 0
                    };
                    
                    showSimilaritiesSummaryModal(tempProcess, data.lastUpdated);
                } else {
                    alert(`Error al cargar similitudes: ${data.error || data.message || 'Error desconocido'}`);
                }
            } catch (error) {
                alert(`Error al cargar similitudes: ${error.message}`);
            }
        }
        
        function showSimilaritiesSummaryModal(processData = null, lastUpdated = null) {
            const modal = document.getElementById('similarities-summary-modal');
            const content = document.getElementById('similarities-summary-content');
            
            // Usar validationProcess si no se proporciona processData
            const similaritiesData = processData || validationProcess;
            
            if (!similaritiesData || !similaritiesData.similarities) {
                content.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No hay datos de similitudes disponibles.</p>';
                modal.style.display = 'block';
                return;
            }
            
            // Contar cu√°ntas llamadas hay por cada grupo
            const groupCounts = new Map();
            allVideos.forEach(video => {
                if (video.group && video.group.trim()) {
                    const groupId = video.group.trim();
                    groupCounts.set(groupId, (groupCounts.get(groupId) || 0) + 1);
                }
            });
            
            // Filtrar relaciones bidireccionales duplicadas
            // Si existe A->B, no mostrar B->A
            // Tambi√©n filtrar si ambas llamadas tienen el mismo grupo
            const seenRelations = new Set();
            const filteredSimilarities = similaritiesData.similarities.filter(sim => {
                const source = sim.source || '';
                const target = sim.target || '';
                
                // Buscar los videos en allVideos
                const sourceVideo = allVideos.find(v => v.fileName === source);
                const targetVideo = allVideos.find(v => v.fileName === target);
                
                // Si ambas llamadas tienen el mismo grupo, omitir esta relaci√≥n
                if (sourceVideo && targetVideo && 
                    sourceVideo.group && sourceVideo.group.trim() && 
                    targetVideo.group && targetVideo.group.trim()) {
                    const sourceGroup = sourceVideo.group.trim();
                    const targetGroup = targetVideo.group.trim();
                    if (sourceGroup === targetGroup) {
                        return false; // Ambas tienen el mismo grupo, no mostrar
                    }
                }
                
                // Crear una clave √∫nica para la relaci√≥n (ordenar alfab√©ticamente para que A->B y B->A tengan la misma clave)
                const relationKey = [source, target].sort().join('|');
                
                // Si ya vimos esta relaci√≥n (en cualquier direcci√≥n), omitirla
                if (seenRelations.has(relationKey)) {
                    return false;
                }
                
                // Marcar esta relaci√≥n como vista
                seenRelations.add(relationKey);
                return true;
            });
            
            // Ordenar similitudes por porcentaje (de mayor a menor)
            const sortedSimilarities = [...filteredSimilarities]
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 10); // Top 10
            
            // Calcular estad√≠sticas usando las similitudes filtradas
            const totalSimilarities = filteredSimilarities.length;
            const avgSimilarity = totalSimilarities > 0
                ? (filteredSimilarities.reduce((sum, s) => sum + s.similarity, 0) / totalSimilarities).toFixed(2)
                : '0.00';
            
            // Formatear fecha de √∫ltima actualizaci√≥n si existe
            const lastUpdatedText = lastUpdated ? new Date(lastUpdated).toLocaleString('es-ES') : (processData ? 'Cargado desde archivo' : 'En proceso');
            
            // Generar contenido del modal
            content.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #333; margin-bottom: 10px;">üìä ${processData ? 'Estad√≠sticas Guardadas' : 'Estad√≠sticas del Proceso'}</h3>
                    ${lastUpdated ? `<div style="font-size: 11px; color: #999; margin-bottom: 10px;">√öltima actualizaci√≥n: ${lastUpdatedText}</div>` : ''}
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
                        ${processData ? '' : `
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Procesadas</div>
                            <div style="font-size: 24px; font-weight: 600; color: #2196F3;">${similaritiesData.processed}/${similaritiesData.total}</div>
                        </div>
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Exitosas</div>
                            <div style="font-size: 24px; font-weight: 600; color: #4CAF50;">${similaritiesData.success}</div>
                        </div>
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Errores</div>
                            <div style="font-size: 24px; font-weight: 600; color: #f44336;">${similaritiesData.errors}</div>
                        </div>
                        `}
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Similitudes Encontradas</div>
                            <div style="font-size: 24px; font-weight: 600; color: #FF9800;">${totalSimilarities}</div>
                        </div>
                    </div>
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Similitud Promedio</div>
                        <div style="font-size: 20px; font-weight: 600; color: #1976D2;">${avgSimilarity}%</div>
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #333; margin-bottom: 15px;">üîù Top 10 Relaciones M√°s Altas</h3>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${sortedSimilarities.length > 0 ? `
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f5f5f5;">
                                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Origen</th>
                                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Destino</th>
                                        <th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd;">Opciones</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedSimilarities.map((sim, index) => {
                                        // Buscar los videos en allVideos
                                        const sourceVideo = allVideos.find(v => v.fileName === sim.source);
                                        const targetVideo = allVideos.find(v => v.fileName === sim.target);
                                        
                                        // Escapar nombres de archivo para uso en atributos onclick
                                        const sourceEscaped = (sim.source || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                        const targetEscaped = (sim.target || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                        
                                        // Determinar si la fila debe tener fondo gris (si source o target tienen grupo con al menos 2 llamadas)
                                        let hasGroupClass = false;
                                        if (sourceVideo && sourceVideo.group && sourceVideo.group.trim()) {
                                            const groupId = sourceVideo.group.trim();
                                            const count = groupCounts.get(groupId) || 0;
                                            if (count >= 2) {
                                                hasGroupClass = true;
                                            }
                                        }
                                        if (!hasGroupClass && targetVideo && targetVideo.group && targetVideo.group.trim()) {
                                            const groupId = targetVideo.group.trim();
                                            const count = groupCounts.get(groupId) || 0;
                                            if (count >= 2) {
                                                hasGroupClass = true;
                                            }
                                        }
                                        
                                        const rowStyle = hasGroupClass 
                                            ? 'border-bottom: 1px solid #eee; background: #bbb;' 
                                            : 'border-bottom: 1px solid #eee;';
                                        
                                        return `
                                        <tr data-similarity-index="${index}" data-source-file="${sourceEscaped}" data-target-file="${targetEscaped}" style="${rowStyle}">
                                            <td style="padding: 10px;">
                                                <div style="display: flex; align-items: flex-start; gap: 8px;">
                                                    <div style="flex: 1;">
                                                        <div style="font-weight: 600; color: #333;">${escapeHtml(sim.sourceTitle || sim.source)}</div>
                                                        <div style="font-size: 11px; color: #999;">${escapeHtml(sim.source)}</div>
                                                        ${sourceVideo ? `
                                                            <div style="margin-top: 4px;">
                                                                ${sourceVideo.youtubeUploaded ? `
                                                                    <span style="display: inline-flex; align-items: center; gap: 4px; background: #4CAF50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                        ‚úÖ YouTube
                                                                        ${sourceVideo.youtubeVideoUrl ? `<a href="${sourceVideo.youtubeVideoUrl}" target="_blank" style="color: white; text-decoration: underline; margin-left: 4px;">üîó</a>` : ''}
                                                                    </span>
                                                                ` : `
                                                                    <span style="display: inline-block; background: #9E9E9E; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                        ‚è∏Ô∏è No subido
                                                                    </span>
                                                                `}
                                                            </div>
                                                        ` : `
                                                            <div style="margin-top: 4px;">
                                                                <span style="display: inline-block; background: #FF9800; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                    ‚ö†Ô∏è Archivo no encontrado
                                                                </span>
                                                            </div>
                                                        `}
                                                    </div>
                                                    ${sourceVideo ? `
                                                        <div style="display: flex; flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                            <button onclick="playAudioFromModal('${sourceEscaped}', ${index})" 
                                                                    style="background: #4CAF50; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Reproducir audio de origen">‚ñ∂Ô∏è</button>
                                                            <button onclick="deleteCallFromModal('${sourceEscaped}', ${index})" 
                                                                    style="background: #f44336; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Eliminar llamada origen">üóëÔ∏è</button>
                                                            <button onclick="blacklistCallFromModal('${sourceEscaped}', ${index})" 
                                                                    style="background: #FF9800; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Agregar a lista negra">üö´</button>
                                                        </div>
                                                    ` : `
                                                        <div style="display: flex; flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                            <button onclick="deleteFromPineconeFromModal('${sourceEscaped}', ${index}, 'source')" 
                                                                    style="background: #9E9E9E; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Eliminar de Pinecone">üóëÔ∏è</button>
                                                        </div>
                                                    `}
                                                </div>
                                            </td>
                                            <td style="padding: 10px;">
                                                <div style="display: flex; align-items: flex-start; gap: 8px;">
                                                    <div style="flex: 1;">
                                                        <div style="font-weight: 600; color: #333;">${escapeHtml(sim.targetTitle || sim.target)}</div>
                                                        <div style="font-size: 11px; color: #999;">${escapeHtml(sim.target)}</div>
                                                        ${targetVideo ? `
                                                            <div style="margin-top: 4px;">
                                                                ${targetVideo.youtubeUploaded ? `
                                                                    <span style="display: inline-flex; align-items: center; gap: 4px; background: #4CAF50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                        ‚úÖ YouTube
                                                                        ${targetVideo.youtubeVideoUrl ? `<a href="${targetVideo.youtubeVideoUrl}" target="_blank" style="color: white; text-decoration: underline; margin-left: 4px;">üîó</a>` : ''}
                                                                    </span>
                                                                ` : `
                                                                    <span style="display: inline-block; background: #9E9E9E; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                        ‚è∏Ô∏è No subido
                                                                    </span>
                                                                `}
                                                            </div>
                                                        ` : `
                                                            <div style="margin-top: 4px;">
                                                                <span style="display: inline-block; background: #FF9800; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                                                    ‚ö†Ô∏è Archivo no encontrado
                                                                </span>
                                                            </div>
                                                        `}
                                                    </div>
                                                    ${targetVideo ? `
                                                        <div style="display: flex; flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                            <button onclick="playAudioFromModal('${targetEscaped}', ${index})" 
                                                                    style="background: #4CAF50; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Reproducir audio de destino">‚ñ∂Ô∏è</button>
                                                            <button onclick="deleteCallFromModal('${targetEscaped}', ${index})" 
                                                                    style="background: #f44336; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Eliminar llamada destino">üóëÔ∏è</button>
                                                            <button onclick="blacklistCallFromModal('${targetEscaped}', ${index})" 
                                                                    style="background: #FF9800; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Agregar a lista negra">üö´</button>
                                                        </div>
                                                    ` : `
                                                        <div style="display: flex; flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                            <button onclick="deleteFromPineconeFromModal('${targetEscaped}', ${index}, 'target')" 
                                                                    style="background: #9E9E9E; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                    title="Eliminar de Pinecone">üóëÔ∏è</button>
                                                        </div>
                                                    `}
                                                </div>
                                            </td>
                                            <td style="padding: 10px; text-align: center;">
                                                <div style="display: flex; flex-direction: column; gap: 8px; align-items: center;">
                                                    <div>
                                                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Similitud</div>
                                                        <span style="font-weight: 600; font-size: 14px; color: ${sim.similarity >= 90 ? '#f44336' : sim.similarity >= 70 ? '#FF9800' : '#4CAF50'};">
                                                            ${sim.similarity.toFixed(2)}%
                                                        </span>
                                                    </div>
                                                    <div>
                                                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Tipo</div>
                                                        <span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; 
                                                            background: ${sim.type === 'duplicate' ? '#ffebee' : sim.type === 'related' ? '#fff3e0' : '#e8f5e9'}; 
                                                            color: ${sim.type === 'duplicate' ? '#c62828' : sim.type === 'related' ? '#e65100' : '#2e7d32'};">
                                                            ${sim.type === 'duplicate' ? 'Duplicado' : sim.type === 'related' ? 'Relacionada' : 'Similar'}
                                                        </span>
                                                    </div>
                                                    ${sourceVideo && targetVideo ? `
                                                        <button onclick="groupCallsFromModal('${sourceEscaped}', '${targetEscaped}', ${index})" 
                                                                style="background: #9C27B0; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                                                title="Agrupar estas dos llamadas">üîó</button>
                                                    ` : ''}
                                                    <button onclick="removeSimilarityFromModal('${sourceEscaped}', '${targetEscaped}', ${index})" 
                                                            style="background: #f44336; color: white; border: none; padding: 6px; font-size: 16px; min-width: 32px; height: 32px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-top: 4px;"
                                                            title="Eliminar esta similitud">üóëÔ∏è</button>
                                                </div>
                                            </td>
                                        </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        ` : '<p style="color: #999; text-align: center; padding: 20px;">No se encontraron similitudes.</p>'}
                    </div>
                </div>
            `;
            
            // Mostrar modal
            modal.style.display = 'block';
            
            // Agregar evento para cerrar modal
            document.getElementById('close-similarities-modal').onclick = () => {
                modal.style.display = 'none';
            };
            
            // Cerrar al hacer clic fuera del modal
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Funciones helper para los botones del modal de similitudes
        async function playAudioFromModal(fileName, index) {
            const video = allVideos.find(v => v.fileName === fileName);
            if (!video) {
                alert(`No se encontr√≥ la llamada: ${fileName}`);
                return;
            }
            
            const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
            const playBtn = document.getElementById(`play-btn-${videoIndex}`);
            if (playBtn) {
                playBtn.click();
            } else {
                // Si no existe el bot√≥n, buscar en la tabla principal
                const optionsPlayBtn = document.getElementById(`options-play-btn-${videoIndex}`);
                if (optionsPlayBtn) {
                    optionsPlayBtn.click();
                } else {
                    alert('No se encontr√≥ el bot√≥n de reproducci√≥n. Por favor, busca la llamada en la tabla principal.');
                }
            }
        }
        
        async function groupCallsFromModal(fileName1, fileName2, index) {
            const video1 = allVideos.find(v => v.fileName === fileName1);
            if (!video1) {
                alert(`No se encontr√≥ la llamada: ${fileName1}`);
                return;
            }
            
            const video2 = allVideos.find(v => v.fileName === fileName2);
            if (!video2) {
                alert(`No se encontr√≥ la llamada: ${fileName2}`);
                return;
            }
            
            // Determinar el grupo a usar
            let groupId;
            if (video1.group && video1.group.trim()) {
                groupId = video1.group.trim();
            } else if (video2.group && video2.group.trim()) {
                groupId = video2.group.trim();
            } else {
                // Generar un ID aleatorio
                groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            // Confirmar agrupaci√≥n
            const confirmMessage = `¬øAgrupar estas dos llamadas?\n\n1. ${video1.title}\n2. ${video2.title}\n\nGrupo: ${groupId}`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Mostrar indicador de carga
            const loadingMsg = document.createElement('div');
            loadingMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #2196F3; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
            loadingMsg.textContent = '‚è≥ Agrupando llamadas...';
            document.body.appendChild(loadingMsg);
            
            try {
                // Actualizar metadata de ambas llamadas
                const updatePromises = [];
                
                // Actualizar la primera llamada
                const currentMetadata1 = video1.fullMetadata || {};
                const updatedCurrentMetadata1 = {
                    ...currentMetadata1,
                    group: groupId
                };
                
                updatePromises.push(
                    fetch(`${API_BASE}/api/video/metadata/${encodeURIComponent(video1.fileName)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedCurrentMetadata1),
                    })
                );
                
                // Actualizar la segunda llamada
                const otherMetadata2 = video2.fullMetadata || {};
                const updatedOtherMetadata2 = {
                    ...otherMetadata2,
                    group: groupId
                };
                
                updatePromises.push(
                    fetch(`${API_BASE}/api/video/metadata/${encodeURIComponent(video2.fileName)}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updatedOtherMetadata2),
                    })
                );
                
                const responses = await Promise.all(updatePromises);
                const results = await Promise.all(responses.map(r => r.json()));
                
                // Verificar que ambas actualizaciones fueron exitosas
                const allSuccess = results.every(r => r.success);
                
                if (allSuccess) {
                    // Eliminar similitudes relacionadas de ambas llamadas del archivo
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: video1.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: video2.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    // Eliminar relaciones del validationProcess si existe
                    if (validationProcess && validationProcess.similarities) {
                        validationProcess.similarities = validationProcess.similarities.filter(sim => {
                            const source = sim.source || '';
                            const target = sim.target || '';
                            // Eliminar si involucra a cualquiera de las dos llamadas
                            return source !== video1.fileName && target !== video1.fileName &&
                                   source !== video2.fileName && target !== video2.fileName;
                        });
                    }
                    
                    // Remover mensaje de carga
                    loadingMsg.remove();
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ Llamadas agrupadas exitosamente con grupo: ${groupId}`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Actualizar ambas filas
                    const videoIndex1 = allVideos.findIndex(v => v.fileName === video1.fileName);
                    if (videoIndex1 !== -1) {
                        await updateSingleVideoRow(videoIndex1, video1.fileName);
                    }
                    const videoIndex2 = allVideos.findIndex(v => v.fileName === video2.fileName);
                    if (videoIndex2 !== -1) {
                        await updateSingleVideoRow(videoIndex2, video2.fileName);
                    }
                    
                    // Si el modal de similitudes est√° abierto, recargarlo
                    const modal = document.getElementById('similarities-summary-modal');
                    if (modal && modal.style.display === 'block') {
                        // Recargar el modal con los datos actualizados
                        showSimilaritiesSummaryModal();
                    }
                } else {
                    throw new Error('Error al actualizar una o ambas llamadas');
                }
            } catch (error) {
                console.error('Error al agrupar llamadas:', error);
                loadingMsg.remove();
                alert(`Error al agrupar llamadas: ${error.message}`);
            }
        }
        
        async function deleteCallFromModal(fileName, index) {
            const video = allVideos.find(v => v.fileName === fileName);
            if (!video) {
                alert(`No se encontr√≥ la llamada: ${fileName}`);
                return;
            }
            
            const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
            
            // Buscar el wrapper en el DOM
            let row = document.getElementById(`video-row-${videoIndex}`);
            if (!row) {
                // Buscar por fileName en los datos
                const body = document.getElementById('videosTableBody');
                if (body) {
                    const wrappers = Array.from(body.querySelectorAll('.video-row-wrapper'));
                    for (const wrapper of wrappers) {
                        const checkbox = wrapper.querySelector(`input[data-video-index="${videoIndex}"]`);
                        if (checkbox) {
                            row = wrapper;
                            break;
                        }
                    }
                }
            }
            
            // Crear un bot√≥n mock si no existe
            const mockButton = {
                disabled: false,
                querySelector: (selector) => {
                    if (row) {
                        return row.querySelector(selector);
                    }
                    return null;
                },
                title: ''
            };
            
            const result = await deleteCallRecord(videoIndex, video, mockButton, row || null);
            
            // Si la eliminaci√≥n fue exitosa, eliminar la fila del modal
            if (result && result.success !== false) {
                removeRowFromSimilaritiesModal(fileName, index);
            }
        }
        
        async function removeSimilarityFromModal(sourceFileName, targetFileName, index) {
            if (!confirm(`¬øEliminar esta similitud?\n\nOrigen: ${sourceFileName}\nDestino: ${targetFileName}`)) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/calls/remove-specific-similarity`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source: sourceFileName,
                        target: targetFileName,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success && data.removed) {
                    // Eliminar del validationProcess si existe
                    if (validationProcess && validationProcess.similarities) {
                        validationProcess.similarities = validationProcess.similarities.filter(
                            sim => !((sim.source === sourceFileName && sim.target === targetFileName) || 
                                    (sim.source === targetFileName && sim.target === sourceFileName))
                        );
                    }
                    
                    // Eliminar la fila del modal
                    removeRowFromSimilaritiesModalByIndex(index);
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001;';
                    successMsg.textContent = '‚úÖ Similitud eliminada exitosamente';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                } else {
                    alert(`Error al eliminar similitud: ${data.message || data.error || 'Error desconocido'}`);
                }
            } catch (error) {
                console.error('Error al eliminar similitud:', error);
                alert(`Error al eliminar similitud: ${error.message}`);
            }
        }
        
        function removeRowFromSimilaritiesModalByIndex(index) {
            const modal = document.getElementById('similarities-summary-modal');
            if (!modal || modal.style.display !== 'block') {
                return;
            }
            
            // Buscar la fila por el √≠ndice de similitud
            const row = modal.querySelector(`tr[data-similarity-index="${index}"]`);
            if (row) {
                // Eliminar la fila con animaci√≥n
                row.style.transition = 'opacity 0.3s';
                row.style.opacity = '0';
                setTimeout(() => {
                    row.remove();
                    console.log(`Fila eliminada del modal de similitudes (√≠ndice: ${index})`);
                    
                    // Si no quedan filas, mostrar mensaje
                    const tbody = modal.querySelector('tbody');
                    if (body && body.children.length === 0) {
                        const content = document.getElementById('similarities-summary-content');
                        if (content) {
                            const table = modal.querySelector('table');
                            if (table) {
                                const newRow = document.createElement('tr');
                                newRow.innerHTML = '<td colspan="3" style="text-align: center; padding: 20px; color: #999;">No quedan similitudes para mostrar</td>';
                                body.appendChild(newRow);
                            }
                        }
                    }
                }, 300);
            }
        }
        
        function removeRowFromSimilaritiesModal(fileName, index) {
            const modal = document.getElementById('similarities-summary-modal');
            if (!modal || modal.style.display !== 'block') {
                return;
            }
            
            // Buscar la fila por el √≠ndice de similitud
            const row = modal.querySelector(`tr[data-similarity-index="${index}"]`);
            if (row) {
                // Verificar si la fila contiene el fileName en source o target
                // Los atributos data tienen caracteres escapados, necesitamos comparar con el fileName original
                const sourceFileAttr = row.getAttribute('data-source-file');
                const targetFileAttr = row.getAttribute('data-target-file');
                
                // Desescapar los atributos para comparar (revertir el escape)
                const sourceFile = sourceFileAttr ? sourceFileAttr.replace(/\\'/g, "'").replace(/&quot;/g, '"') : null;
                const targetFile = targetFileAttr ? targetFileAttr.replace(/\\'/g, "'").replace(/&quot;/g, '"') : null;
                
                // Si el fileName coincide con source o target, eliminar toda la fila
                if (sourceFile === fileName || targetFile === fileName) {
                    // Remover del array de similitudes si existe
                    if (validationProcess && validationProcess.similarities) {
                        validationProcess.similarities = validationProcess.similarities.filter(
                            sim => !(sim.source === fileName || sim.target === fileName)
                        );
                    }
                    
                    // Eliminar la fila con animaci√≥n
                    row.style.transition = 'opacity 0.3s';
                    row.style.opacity = '0';
                    setTimeout(() => {
                        row.remove();
                        console.log(`Fila eliminada del modal de similitudes para ${fileName}`);
                        
                        // Si no quedan filas, mostrar mensaje
                        const tbody = modal.querySelector('tbody');
                        if (body && body.children.length === 0) {
                            const content = document.getElementById('similarities-summary-content');
                            if (content) {
                                const noDataMsg = content.querySelector('p');
                                if (!noDataMsg || !noDataMsg.textContent.includes('No se encontraron similitudes')) {
                                    const table = modal.querySelector('table');
                                    if (table) {
                                        const newRow = document.createElement('tr');
                                        newRow.innerHTML = '<td colspan="3" style="text-align: center; padding: 20px; color: #999;">No quedan similitudes para mostrar</td>';
                                        body.appendChild(newRow);
                                    }
                                }
                            }
                        }
                    }, 300);
                }
            }
        }
        
        async function blacklistCallFromModal(fileName, index) {
            const video = allVideos.find(v => v.fileName === fileName);
            if (!video) {
                alert(`No se encontr√≥ la llamada: ${fileName}`);
                return;
            }
            
            const videoIndex = allVideos.findIndex(v => v.fileName === fileName);
            
            // Buscar el wrapper en el DOM
            let row = document.getElementById(`video-row-${videoIndex}`);
            if (!row) {
                // Buscar por fileName en los datos
                const body = document.getElementById('videosTableBody');
                if (body) {
                    const wrappers = Array.from(body.querySelectorAll('.video-row-wrapper'));
                    for (const wrapper of wrappers) {
                        const checkbox = wrapper.querySelector(`input[data-video-index="${videoIndex}"]`);
                        if (checkbox) {
                            row = wrapper;
                            break;
                        }
                    }
                }
            }
            
            // Crear un bot√≥n mock si no existe
            const mockButton = {
                disabled: false,
                querySelector: (selector) => {
                    if (row) {
                        return row.querySelector(selector);
                    }
                    return null;
                },
                title: ''
            };
            
            const result = await blacklistCallRecord(videoIndex, video, mockButton, row || null);
            
            // Si la acci√≥n fue exitosa, eliminar la fila del modal
            if (result && result.success !== false) {
                removeRowFromSimilaritiesModal(fileName, index);
            }
        }
        
        async function deleteFromPineconeFromModal(fileName, index, type) {
            // Confirmar acci√≥n
            const confirmMessage = `¬øEst√°s seguro de que deseas eliminar este registro de Pinecone?\n\nArchivo: ${fileName}\n\nEsta acci√≥n eliminar√° el registro de Pinecone pero NO eliminar√° los archivos locales (si existen). Esta acci√≥n no se puede deshacer.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Mostrar indicador de carga
            const loadingMsg = document.createElement('div');
            loadingMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #2196F3; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
            loadingMsg.textContent = '‚è≥ Eliminando de Pinecone...';
            document.body.appendChild(loadingMsg);
            
            try {
                const response = await fetch(`${API_BASE}/api/calls/delete-from-pinecone`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: fileName,
                    }),
                });
                
                const data = await response.json();
                
                loadingMsg.remove();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ Registro eliminado de Pinecone: ${fileName}`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Eliminar la fila del modal si el archivo ya no existe en allVideos
                    // (si se elimin√≥ de Pinecone y no existe localmente, eliminar la fila)
                    const videoExists = allVideos.find(v => v.fileName === fileName);
                    if (!videoExists) {
                        // Si el video no existe localmente, eliminar la fila completa
                        removeRowFromSimilaritiesModal(fileName, index);
                    } else {
                        // Si el video existe localmente, solo deshabilitar el bot√≥n
                        const modal = document.getElementById('similarities-summary-modal');
                        if (modal && modal.style.display === 'block') {
                            // Buscar el bot√≥n en el modal y deshabilitarlo o cambiarlo
                            const buttons = modal.querySelectorAll(`button[onclick*="${fileName.replace(/'/g, "\\'")}"]`);
                            buttons.forEach(btn => {
                                if (btn.title === 'Eliminar de Pinecone') {
                                    btn.disabled = true;
                                    btn.style.opacity = '0.5';
                                    btn.style.cursor = 'not-allowed';
                                    btn.title = 'Ya eliminado de Pinecone';
                                }
                            });
                        }
                    }
                } else {
                    throw new Error(data.error || data.message || 'Error al eliminar de Pinecone');
                }
            } catch (error) {
                loadingMsg.remove();
                
                // Mostrar mensaje de error
                const errorMsg = document.createElement('div');
                errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #f44336; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                errorMsg.textContent = `‚ùå Error al eliminar de Pinecone: ${error.message}`;
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.remove();
                }, 5000);
            }
        }
        
        async function blacklistCallRecord(videoIndex, video, button, row) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øEst√°s seguro de que deseas agregar este video a la lista negra?\n\nT√≠tulo: ${video.title}\nID: ${video.youtubeVideoId || 'N/A'}\n\nEsto agregar√° el video a la lista negra y eliminar√° TODOS los archivos relacionados. Esta acci√≥n no se puede deshacer.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const iconSpan = button.querySelector('.icon');
            if (iconSpan) {
                iconSpan.textContent = '‚è≥';
            }
            button.title = 'Agregando...';
            
            try {
                const response = await fetch(`${API_BASE}/api/video/blacklist/${encodeURIComponent(video.fileName)}`, {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Eliminar similitudes relacionadas del archivo
                    try {
                        await fetch(`${API_BASE}/api/calls/remove-similarities`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fileName: video.fileName,
                            }),
                        });
                    } catch (error) {
                        console.warn('Error al eliminar similitudes del archivo:', error);
                    }
                    
                    if (row) {
                        // Encontrar el wrapper que contiene la fila y el contenedor de detalles
                        const rowWrapper = row.parentElement;
                        
                        // Eliminar el wrapper completo (fila + detalles)
                        if (rowWrapper && rowWrapper.classList.contains('video-row-wrapper')) {
                            rowWrapper.style.transition = 'opacity 0.3s';
                            rowWrapper.style.opacity = '0';
                            
                            setTimeout(() => {
                                rowWrapper.remove();
                            }, 300);
                        } else {
                            // Fallback: eliminar solo la fila si no se encuentra el wrapper
                            row.style.transition = 'opacity 0.3s';
                            row.style.opacity = '0';
                            
                            setTimeout(() => {
                                row.remove();
                            }, 300);
                        }
                    }
                    
                    // Actualizar estad√≠sticas
                    allVideos = allVideos.filter(v => v.fileName !== video.fileName);
                    updateStats();
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ff9800; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = `‚úÖ Video agregado a lista negra y ${data.deletedCount} archivos eliminados`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    return { success: true };
                } else {
                    throw new Error(data.error || data.message || 'Error al agregar a lista negra');
                }
            } catch (error) {
                alert(`Error al agregar a lista negra: ${error.message}`);
                button.disabled = false;
                if (iconSpan) {
                    iconSpan.textContent = 'üö´';
                }
                button.title = 'Lista Negra';
                return { success: false, error: error.message };
            }
        }
        
        async function generateVideoFromCall(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            if (!video.fullMetadata) {
                alert('Error: No se encontr√≥ el metadata completo del video');
                return;
            }
            
            // Obtener rutas de archivos del metadata
            const metadata = video.fullMetadata;
            
            // Construir ruta del audio
            // El audio se guarda como {fileName}.mp3 en storage/calls
            let audioPath = metadata.audioFile;
            if (!audioPath) {
                // Si no est√° en metadata, construir la ruta
                audioPath = `storage/calls/${video.fileName}.mp3`;
            }
            
            // Normalizar rutas: convertir rutas absolutas de Windows a formato relativo si es necesario
            // Las rutas absolutas en Windows tienen formato: C:\Users\...\storage\calls\...
            // Necesitamos convertirlas a formato relativo: storage/calls/...
            if (audioPath.includes('\\')) {
                // Es una ruta de Windows, extraer la parte relativa
                const parts = audioPath.split(/[/\\]/);
                const storageIndex = parts.findIndex(p => p === 'storage');
                if (storageIndex >= 0) {
                    audioPath = parts.slice(storageIndex).join('/');
                }
            }
            
            // Usar SOLO la miniatura generada (no la original)
            let imagePath = null;
            if (metadata.generatedThumbnailPath) {
                imagePath = metadata.generatedThumbnailPath;
            } else if (video.generatedThumbnailUrl) {
                // Si no hay ruta en metadata, construir desde fileName
                imagePath = `storage/calls/${video.fileName}_generated.jpg`;
            }
            
            if (!imagePath) {
                alert('Error: No se encontr√≥ la miniatura generada. Por favor, genera una miniatura primero antes de crear el video.');
                return;
            }
            
            // Normalizar ruta de imagen tambi√©n
            if (imagePath.includes('\\')) {
                const parts = imagePath.split(/[/\\]/);
                const storageIndex = parts.findIndex(p => p === 'storage');
                if (storageIndex >= 0) {
                    imagePath = parts.slice(storageIndex).join('/');
                }
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øGenerar video para esta llamada?\n\nT√≠tulo: ${video.title}\n\nAudio: ${audioPath}\nImagen: ${imagePath}\n\nEl video se guardar√° en la misma carpeta que el audio.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            button.textContent = 'Generando...';
            
            try {
                // Construir ruta de salida (misma carpeta que el audio, con extensi√≥n .mp4)
                // Extraer el directorio del audioPath
                const lastSlash = audioPath.lastIndexOf('/');
                const audioDir = lastSlash >= 0 ? audioPath.substring(0, lastSlash) : 'storage/calls';
                const outputPath = `${audioDir}/${video.fileName}.mp4`;
                
                const response = await fetch(`${API_BASE}/api/video/generate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        audioPath: audioPath,
                        imagePath: imagePath,
                        outputPath: outputPath,
                        visualizationType: 'bars', // Barras de audio "bars" o  "waves"
                        barCount: 32, // Menos barras para mejor visualizaci√≥n
                        barPositionY: null, // Posici√≥n Y de las barras (null = autom√°tico con margen del 10%)
                        barOpacity: 0.8, // Opacidad de las barras (0.0 a 1.0)
                        videoCodec: 'libx264',
                        audioCodec: 'aac',
                        fps: 30,
                        resolution: '1920x1080',
                        bitrate: 5000,
                        videoTitle: video.title || video.fileName, // T√≠tulo para mostrar en el progreso
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success && data.generationId) {
                    const generationId = data.generationId;
                    const videoTitle = video.title || video.fileName;
                    
                    // Guardar generationId en localStorage
                    saveGenerationId(generationId);
                    
                    // Guardar referencia del bot√≥n para actualizar su progreso
                    generationButtons.set(generationId, {
                        button: button,
                        fileName: video.fileName
                    });
                    
                    // Crear elemento de progreso (pasar fileName para poder hacer scroll)
                    createProgressElement('generation', generationId, videoTitle, video.fileName);
                    
                    // Conectar a SSE
                    connectToProgressSSE('generation', generationId);
                    
                    // Deshabilitar bot√≥n y mostrar progreso inicial
                    button.disabled = true;
                    const textSpan = button.querySelector('.text');
                    if (textSpan) {
                        textSpan.textContent = 'Generar Video (0%)';
                    }
                    
                    // Actualizar solo el registro modificado cuando se complete (se maneja en el SSE)
                } else {
                    throw new Error(data.error || data.message || 'Error al generar video');
                }
            } catch (error) {
                alert(`Error al generar video: ${error.message}`);
                // Rehabilitar bot√≥n
                button.disabled = false;
                const textSpan = button.querySelector('.text');
                if (textSpan) {
                    textSpan.textContent = 'Generar Video';
                }
            }
        }
        
        async function generateShortFromCall(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Validar que el video tiene youtubeVideoUrl
            if (!video.youtubeVideoUrl) {
                alert('Error: El video no tiene youtubeVideoUrl en su metadata. No se puede generar short sin transcripci√≥n de YouTube.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øGenerar video short vertical (1080x1920) para esta llamada?\n\nT√≠tulo: ${video.title}\n\nSe usar√°:\n- Miniatura generada\n- Videos de fondo aleatorios\n- Subt√≠tulos desde YouTube\n- Waveform vertical\n\nEl short se guardar√° como ${video.fileName}_short.mp4`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const textSpan = button.querySelector('.text');
            if (textSpan) {
                textSpan.textContent = 'Generando...';
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/video/generate-short`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: video.fileName,
                        youtubeVideoUrl: video.youtubeVideoUrl
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success && data.shortId) {
                    const shortId = data.shortId;
                    const videoTitle = video.title || video.fileName;
                    
                    // Guardar shortId en localStorage
                    saveShortId(shortId);
                    
                    // Guardar referencia del bot√≥n para actualizar su progreso
                    shortButtons.set(shortId, {
                        button: button,
                        fileName: video.fileName
                    });
                    
                    // Crear elemento de progreso
                    createProgressElement('short', shortId, videoTitle, video.fileName);
                    
                    // Conectar a SSE
                    connectToProgressSSE('short', shortId);
                    
                    // Deshabilitar bot√≥n y mostrar progreso inicial
                    button.disabled = true;
                    if (textSpan) {
                        textSpan.textContent = 'Generar Short (0%)';
                    }
                } else {
                    throw new Error(data.error || data.message || 'Error al generar short');
                }
            } catch (error) {
                alert(`Error al generar short: ${error.message}`);
                // Rehabilitar bot√≥n
                button.disabled = false;
                if (textSpan) {
                    textSpan.textContent = 'Generar Short';
                }
            }
        }
        
        async function uploadVideoToYouTube(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            if (!video.hasVideo) {
                alert('Error: No hay video generado para subir');
                return;
            }
            
            if (!video.fullMetadata) {
                alert('Error: No se encontr√≥ el metadata completo del video');
                return;
            }
            
            // Obtener rutas de archivos del metadata
            const metadata = video.fullMetadata;
            
            // Construir ruta del video
            let videoPath = video.videoPath;
            if (!videoPath) {
                videoPath = `storage/calls/${video.fileName}.mp4`;
            }
            
            // Normalizar ruta: convertir rutas absolutas de Windows a formato relativo si es necesario
            if (videoPath.includes('\\')) {
                const parts = videoPath.split(/[/\\]/);
                const storageIndex = parts.findIndex(p => p === 'storage');
                if (storageIndex >= 0) {
                    videoPath = parts.slice(storageIndex).join('/');
                }
            }
            
            // Construir ruta del metadata
            const metadataPath = `storage/calls/${video.fileName}.json`;
            
            // Usar la miniatura generada si existe, sino la original
            let thumbnailPath = null;
            if (metadata.generatedThumbnailPath) {
                thumbnailPath = metadata.generatedThumbnailPath;
            } else if (metadata.originalThumbnailPath) {
                thumbnailPath = metadata.originalThumbnailPath;
            } else if (video.generatedThumbnailUrl) {
                // Si no est√° en metadata, construir desde el fileName
                thumbnailPath = `storage/calls/${video.fileName}_generated.jpg`;
            } else if (video.originalThumbnailUrl) {
                // Usar miniatura original como fallback
                thumbnailPath = `storage/calls/${video.fileName}_original.jpg`;
            }
            
            // Normalizar ruta de miniatura tambi√©n
            if (thumbnailPath && thumbnailPath.includes('\\')) {
                const parts = thumbnailPath.split(/[/\\]/);
                const storageIndex = parts.findIndex(p => p === 'storage');
                if (storageIndex >= 0) {
                    thumbnailPath = parts.slice(storageIndex).join('/');
                }
            }
            
            // Log para debugging
            console.log('[Upload YouTube] Thumbnail path:', thumbnailPath);
            console.log('[Upload YouTube] Video generatedThumbnailUrl:', video.generatedThumbnailUrl);
            console.log('[Upload YouTube] Video originalThumbnailUrl:', video.originalThumbnailUrl);
            console.log('[Upload YouTube] Metadata generatedThumbnailPath:', metadata.generatedThumbnailPath);
            console.log('[Upload YouTube] Metadata originalThumbnailPath:', metadata.originalThumbnailPath);
            
            // Confirmar acci√≥n
            let confirmMessage = `¬øSubir video a YouTube?\n\nT√≠tulo: ${video.title}\n\nVideo: ${videoPath}`;
            if (thumbnailPath) {
                confirmMessage += `\n\nMiniatura: ${thumbnailPath}`;
            } else {
                confirmMessage += `\n\n‚ö†Ô∏è Advertencia: No se encontr√≥ miniatura. El video se subir√° sin miniatura.`;
            }
            confirmMessage += `\n\nEl video se subir√° como p√∫blico por defecto.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalButtonText = button.textContent;
            
            try {
                const response = await fetch(`${API_BASE}/api/video/upload-to-youtube`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        videoPath: videoPath,
                        title: video.title,
                        description: metadata.shortDescription || metadata.description || '',
                        tags: metadata.tags || [],
                        privacyStatus: 'public',
                        thumbnailPath: thumbnailPath,
                        metadataPath: metadataPath,
                    }),
                });
                
                // Leer la respuesta
                const data = await response.json();
                
                // Si la respuesta incluye uploadId, crear elemento de progreso y conectar a SSE
                if (data.uploadId) {
                    // Crear elemento de progreso
                    createProgressElement('upload', data.uploadId, video.title, video.fileName);
                    
                    // Conectar a SSE
                    connectToProgressSSE('upload', data.uploadId);
                    
                    // Guardar uploadId en localStorage
                    const stored = JSON.parse(localStorage.getItem('youtubeUploads') || '[]');
                    if (!stored.includes(data.uploadId)) {
                        stored.push(data.uploadId);
                        localStorage.setItem('youtubeUploads', JSON.stringify(stored));
                    }
                    
                    // Actualizar bot√≥n con progreso inicial
                    button.textContent = 'Subiendo... (0%)';
                }
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito con informaci√≥n de la miniatura
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000; max-width: 400px;';
                    
                    let message = `‚úÖ Video subido exitosamente a YouTube!<br><a href="${data.videoUrl}" target="_blank" style="color: white; text-decoration: underline;">Ver en YouTube</a>`;
                    
                    if (data.thumbnailUploaded) {
                        message += '<br><br>üì∏ Miniatura subida exitosamente.';
                    } else if (data.thumbnailError) {
                        message += `<br><br>‚ö†Ô∏è <strong>Advertencia:</strong> No se pudo subir la miniatura:<br><small>${data.thumbnailError}</small>`;
                        successMsg.style.background = '#FF9800'; // Cambiar a naranja si hay advertencia
                    } else {
                        message += '<br><br>‚ö†Ô∏è <strong>Advertencia:</strong> No se subi√≥ miniatura (no se especific√≥ ruta).';
                        successMsg.style.background = '#FF9800'; // Cambiar a naranja si hay advertencia
                    }
                    
                    successMsg.innerHTML = message;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 10000); // Aumentar tiempo si hay advertencia
                    
                    // Actualizar solo el registro modificado
                    setTimeout(() => {
                        updateSingleVideoRow(videoIndex, video.fileName);
                    }, 500);
                } else {
                    // Si requiere autenticaci√≥n, mostrar bot√≥n de login
                    if (data.requiresAuth || data.requiresReauth || (data.error && (data.error.includes('token') || data.error.includes('autenticaci√≥n') || data.error.includes('authentication')))) {
                        // Ocultar informaci√≥n del canal si est√° visible
                        const channelInfo = document.getElementById('youtube-channel-info');
                        if (channelInfo) {
                            channelInfo.style.display = 'none';
                        }
                        
                        // Mostrar bot√≥n de login
                        const loginContainer = document.getElementById('youtube-login-container');
                        const loginBtn = document.getElementById('youtube-login-btn');
                        
                        if (loginContainer && loginBtn) {
                            loginContainer.style.display = 'block';
                            
                            // Obtener URL de autenticaci√≥n si no est√° en la respuesta
                            let authUrl = data.authUrl;
                            if (!authUrl) {
                                try {
                                    const authUrlResponse = await fetch(`${API_BASE}/api/video/youtube/auth-url`);
                                    const authUrlData = await authUrlResponse.json();
                                    if (authUrlData.success && authUrlData.authUrl) {
                                        authUrl = authUrlData.authUrl;
                                    }
                                } catch (err) {
                                    console.error('Error al obtener URL de autenticaci√≥n:', err);
                                }
                            }
                            
                            if (authUrl) {
                                loginBtn.setAttribute('data-auth-url', authUrl);
                            }
                            
                            // Mostrar mensaje informativo
                            alert('üîê Autenticaci√≥n de YouTube requerida\n\nPor favor, haz clic en el bot√≥n "üî¥ Login YouTube" en la parte superior de la p√°gina para autenticarte.\n\nDespu√©s de autenticarte, podr√°s subir videos a YouTube.');
                        } else {
                            // Fallback: usar el m√©todo anterior si no se encuentra el bot√≥n
                            if (data.authUrl) {
                                window.open(data.authUrl, '_blank');
                                alert('üîê Autenticaci√≥n de YouTube requerida\n\nSe ha abierto una nueva pesta√±a. Por favor, autentica la aplicaci√≥n y luego intenta subir el video nuevamente.');
                            } else {
                                alert('üîê Autenticaci√≥n de YouTube requerida\n\nPor favor, autentica la aplicaci√≥n desde la configuraci√≥n de YouTube.');
                            }
                        }
                    } else {
                        throw new Error(data.error || data.message || 'Error al subir video');
                    }
                }
            } catch (error) {
                // Si el error es por falta de token o autenticaci√≥n, mostrar bot√≥n de login
                if (error.message.includes('token') || error.message.includes('autenticaci√≥n') || error.message.includes('authentication') || error.message.includes('autentica primero')) {
                    // Ocultar informaci√≥n del canal si est√° visible
                    const channelInfo = document.getElementById('youtube-channel-info');
                    if (channelInfo) {
                        channelInfo.style.display = 'none';
                    }
                    
                    // Mostrar bot√≥n de login
                    const loginContainer = document.getElementById('youtube-login-container');
                    const loginBtn = document.getElementById('youtube-login-btn');
                    
                    if (loginContainer && loginBtn) {
                        loginContainer.style.display = 'block';
                        
                        // Intentar obtener URL de autenticaci√≥n
                        try {
                            const authUrlResponse = await fetch(`${API_BASE}/api/video/youtube/auth-url`);
                            const authUrlData = await authUrlResponse.json();
                            if (authUrlData.success && authUrlData.authUrl) {
                                loginBtn.setAttribute('data-auth-url', authUrlData.authUrl);
                            }
                        } catch (err) {
                            console.error('Error al obtener URL de autenticaci√≥n:', err);
                        }
                        
                        // Mostrar mensaje informativo
                        alert('üîê Autenticaci√≥n de YouTube requerida\n\nPor favor, haz clic en el bot√≥n "üî¥ Login YouTube" en la parte superior de la p√°gina para autenticarte.\n\nDespu√©s de autenticarte, podr√°s subir videos a YouTube.');
                    } else {
                        // Fallback: mostrar mensaje gen√©rico
                        alert(`üîê Autenticaci√≥n de YouTube requerida\n\n${error.message}\n\nPor favor, autentica la aplicaci√≥n desde la configuraci√≥n de YouTube.`);
                    }
                } else {
                    alert(`Error al subir video a YouTube: ${error.message}`);
                }
                
                // Detener el polling si hay error
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
            } finally {
                // Detener el polling si existe
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                
                // Rehabilitar bot√≥n solo si no se subi√≥ exitosamente
                if (!video.youtubeUploaded) {
                    button.disabled = false;
                    if (!button.textContent.includes('Completado') && !button.textContent.includes('Error')) {
                        button.textContent = 'üì§ Subir';
                    }
                }
            }
        }
        
        async function downloadOriginalThumbnail(videoIndex, video, button, container) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            button.textContent = 'Descargando...';
            const loadingOverlay = container.querySelector('.thumbnail-loading');
            if (loadingOverlay) {
                loadingOverlay.classList.add('active');
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/video/thumbnail/original/download/${encodeURIComponent(video.fileName)}`, {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Actualizar la imagen en la tabla
                    const imgId = `original-thumb-${videoIndex}`;
                    let img = document.getElementById(imgId);
                    
                    if (!img || img.tagName !== 'IMG') {
                        // Si no existe o es un placeholder, crear nueva imagen
                        const oldElement = document.getElementById(imgId);
                        if (oldElement) {
                            oldElement.remove();
                        }
                        img = document.createElement('img');
                        img.id = imgId;
                        img.className = 'thumbnail';
                        img.alt = 'Miniatura original';
                        container.insertBefore(img, button);
                    }
                    
                    // Actualizar la URL de la imagen con un timestamp para forzar recarga
                    const newUrl = `/api/video/thumbnail/original/${encodeURIComponent(video.fileName)}?t=${Date.now()}`;
                    img.src = newUrl;
                    img.onerror = function() {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'thumbnail-placeholder';
                        placeholder.id = imgId;
                        placeholder.textContent = 'Sin imagen';
                        this.parentElement.replaceChild(placeholder, this);
                    };
                    
                    // Actualizar el bot√≥n
                    button.textContent = 'üîÑ Regenerar';
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Miniatura original descargada exitosamente';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                } else {
                    throw new Error(data.error || data.message || 'Error al descargar miniatura');
                }
            } catch (error) {
                alert(`Error al descargar miniatura original: ${error.message}`);
                button.textContent = video.originalThumbnailUrl ? 'üîÑ Regenerar' : '‚¨áÔ∏è Descargar';
            } finally {
                // Rehabilitar bot√≥n y ocultar loading
                button.disabled = false;
                if (loadingOverlay) {
                    loadingOverlay.classList.remove('active');
                }
            }
        }
        
        /**
         * Combina los videos seleccionados
         */
        async function combineSelectedVideos() {
            if (selectedVideos.length < 2) {
                alert('Selecciona al menos 2 videos para combinar');
                return;
            }
            
            // Obtener los nombres de archivo de los videos seleccionados
            const fileNames = selectedVideos.map(index => allVideos[index].fileName).filter(name => name);
            
            if (fileNames.length < 2) {
                alert('Error: No se pudieron obtener los nombres de archivo de los videos seleccionados');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øEst√°s seguro de que quieres combinar ${fileNames.length} llamadas?\n\nVideos a combinar:\n${fileNames.map((name, i) => `${i + 1}. ${name}`).join('\n')}`;
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                const combineBtn = document.getElementById('combine-floating-btn');
                if (combineBtn) {
                    combineBtn.disabled = true;
                    combineBtn.textContent = '‚è≥ Combinando...';
                }
                
                const response = await fetch(`${API_BASE}/api/video/merge`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileNames: fileNames,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1001;';
                    successMsg.textContent = `‚úÖ ${fileNames.length} llamadas combinadas exitosamente`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 5000);
                    
                    // Limpiar selecci√≥n
                    selectedVideos = [];
                    updateCombineButton();
                    
                    // Recargar la lista de videos
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                } else {
                    throw new Error(data.error || data.message || 'Error al combinar videos');
                }
            } catch (error) {
                console.error('Error al combinar videos:', error);
                alert(`Error al combinar videos: ${error.message}`);
                
                const combineBtn = document.getElementById('combine-floating-btn');
                if (combineBtn) {
                    combineBtn.disabled = false;
                    updateCombineButton();
                }
            }
        }
        
        /**
         * Actualiza solo un registro de video en el DOM sin recargar toda la lista
         * @param {number} videoIndex - √çndice del video en allVideos
         * @param {string} fileName - Nombre del archivo del video
         */
        async function updateSingleVideoRow(videoIndex, fileName) {
            try {
                // Obtener la lista actualizada de videos desde el backend
                const listResponse = await fetch(`${API_BASE}/api/video/list`);
                const listData = await listResponse.json();
                
                if (!listResponse.ok || !listData.videos) {
                    console.warn('Error al obtener la lista actualizada, recargando toda la p√°gina...');
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                    return;
                }
                
                // Encontrar el video actualizado en la lista
                const updatedVideo = listData.videos.find(v => v.fileName === fileName);
                
                if (!updatedVideo) {
                    console.warn('No se encontr√≥ el video actualizado en la lista, recargando toda la p√°gina...');
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                    return;
                }
                
                // Encontrar el wrapper en el DOM
                const mainRow = document.getElementById(`video-row-${videoIndex}`);
                
                // Si no se encuentra por ID, buscar por fileName en los datos
                let foundMainRow = null;
                let insertBeforeElement = null;
                
                if (!mainRow) {
                    // Buscar el wrapper en el DOM usando el fileName
                    const body = document.getElementById('videosTableBody');
                    const wrappers = Array.from(body.querySelectorAll('.video-row-wrapper'));
                    
                    for (let i = 0; i < wrappers.length; i++) {
                        const wrapper = wrappers[i];
                        // Verificar si este wrapper contiene el video que estamos buscando
                        const checkbox = wrapper.querySelector(`input[data-video-index="${videoIndex}"]`);
                        if (checkbox) {
                            foundMainRow = wrapper;
                            // Guardar referencia al elemento siguiente para insertar despu√©s
                            if (i + 1 < wrappers.length) {
                                insertBeforeElement = wrappers[i + 1];
                            }
                            break;
                        }
                    }
                } else {
                    foundMainRow = mainRow;
                    // Guardar referencia al elemento siguiente
                    insertBeforeElement = mainRow.nextElementSibling;
                }
                
                if (foundMainRow) {
                    // Eliminar la fila del DOM
                    foundMainRow.remove();
                    
                    // Actualizar allVideos con el video actualizado
                    allVideos[videoIndex] = updatedVideo;
                    
                    // Re-renderizar solo este video
                    const body = document.getElementById('videosTableBody');
                    
                    // Obtener el siguiente elemento para insertar despu√©s
                    const nextSibling = insertBeforeElement || null;
                    
                    // Renderizar solo este video usando displayVideos con el √≠ndice correcto
                    const tempBody = document.createElement('div');
                    tempBody.className = 'videos-body';
                    const singleVideoArray = [updatedVideo];
                    
                    // Renderizar el video con el videoIndex correcto
                    displayVideos(singleVideoArray, tempBody, videoIndex);
                    
                    // Obtener la fila renderizada
                    const newRows = Array.from(tempBody.children);
                    
                    if (newRows.length >= 1) {
                        const newMainRow = newRows[0];
                        
                        // Insertar la nueva fila en la posici√≥n correcta
                        if (nextSibling && nextSibling.parentElement === body) {
                            body.insertBefore(newMainRow, nextSibling);
                        } else {
                            body.appendChild(newMainRow);
                        }
                        
                        // Aplicar el estado del toggle de miniaturas originales a la nueva fila
                        const showOriginalCheckbox = document.getElementById('showOriginalThumbnails');
                        if (showOriginalCheckbox) {
                            const showOriginal = showOriginalCheckbox.checked;
                            const newOriginalThumbCell = newMainRow.querySelector('.thumbnail-original-column');
                            
                            if (newOriginalThumbCell) {
                                if (showOriginal) {
                                    newOriginalThumbCell.classList.remove('hidden');
                                } else {
                                    newOriginalThumbCell.classList.add('hidden');
                                }
                            }
                        }
                        
                        // Actualizar contador del bot√≥n de subida masiva
                        updateBulkUploadCounter();
                        
                        // No llamar a applyFilters() aqu√≠ porque re-renderiza todos los videos
                        // La fila ya est√° actualizada y los filtros no deber√≠an cambiar
                    }
                } else {
                    // Si no se encontraron las filas, recargar toda la p√°gina
                    console.warn('No se encontraron las filas para actualizar, recargando toda la p√°gina...');
                    setTimeout(() => {
                        loadVideos();
                    }, 1000);
                }
            } catch (error) {
                console.error('Error al actualizar fila individual:', error);
                // Si falla, recargar toda la p√°gina como fallback
                setTimeout(() => {
                    loadVideos();
                }, 1000);
            }
        }
        
        async function updateCallContent(videoIndex, video, button) {
            if (!video.fileName) {
                alert('Error: No se encontr√≥ el nombre del archivo');
                return;
            }
            
            if (!video.youtubeVideoId && !video.youtubeUrl) {
                alert('Error: No se encontr√≥ el ID o URL de YouTube. No se puede actualizar el contenido.');
                return;
            }
            
            // Confirmar acci√≥n
            const confirmMessage = `¬øActualizar todo el contenido de esta llamada?\n\nT√≠tulo: ${video.title}\n\nEsto re-descargar√°:\n- Audio desde YouTube\n- Miniatura original\n- Metadata actualizado\n\n¬øContinuar?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar loading
            button.disabled = true;
            const originalText = button.textContent;
            button.textContent = 'Actualizando...';
            
            try {
                // Obtener la URL de YouTube
                const youtubeUrl = video.youtubeUrl || (video.youtubeVideoId ? `https://www.youtube.com/watch?v=${video.youtubeVideoId}` : null);
                
                if (!youtubeUrl) {
                    throw new Error('No se pudo obtener la URL de YouTube');
                }
                
                const response = await fetch(`${API_BASE}/api/video/update-call-content`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: video.fileName,
                        youtubeUrl: youtubeUrl,
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Contenido actualizado exitosamente';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                    // Obtener la lista actualizada de videos desde el backend
                    const listResponse = await fetch(`${API_BASE}/api/video/list`);
                    const listData = await listResponse.json();
                    
                    if (listResponse.ok && listData.videos) {
                        // Encontrar el video actualizado en la lista
                        const updatedVideo = listData.videos.find(v => v.fileName === video.fileName);
                        
                        if (updatedVideo) {
                            // Encontrar el wrapper en el DOM
                            const mainRow = document.getElementById(`video-row-${videoIndex}`);
                            
                            // Si no se encuentra por ID, buscar por fileName en los datos
                            let foundMainRow = null;
                            let insertBeforeElement = null;
                            
                            if (!mainRow) {
                                // Buscar el wrapper en el DOM usando el fileName
                                const body = document.getElementById('videosTableBody');
                                const wrappers = Array.from(body.querySelectorAll('.video-row-wrapper'));
                                
                                for (let i = 0; i < wrappers.length; i++) {
                                    const wrapper = wrappers[i];
                                    // Verificar si este wrapper contiene el video que estamos buscando
                                    const checkbox = wrapper.querySelector(`input[data-video-index="${videoIndex}"]`);
                                    if (checkbox) {
                                        foundMainRow = wrapper;
                                        // Guardar referencia al elemento siguiente para insertar despu√©s
                                        if (i + 1 < wrappers.length) {
                                            insertBeforeElement = wrappers[i + 1];
                                        }
                                        break;
                                    }
                                }
                            } else {
                                foundMainRow = mainRow;
                                // Guardar referencia al elemento siguiente
                                insertBeforeElement = mainRow.nextElementSibling;
                            }
                            
                            if (foundMainRow) {
                                // Eliminar el wrapper del DOM
                                foundMainRow.remove();
                                
                                // Actualizar allVideos con el video actualizado
                                allVideos[videoIndex] = updatedVideo;
                                
                                // Re-renderizar solo este video
                                const body = document.getElementById('videosTableBody');
                                
                                // Obtener el siguiente elemento para insertar despu√©s
                                const nextSibling = insertBeforeElement || null;
                                
                                // Renderizar solo este video usando displayVideos con el √≠ndice correcto
                                const tempBody = document.createElement('div');
                                tempBody.className = 'videos-body';
                                const singleVideoArray = [updatedVideo];
                                
                                // Renderizar el video con el videoIndex correcto
                                displayVideos(singleVideoArray, tempBody, videoIndex);
                                
                                // Obtener el wrapper renderizado
                                const newRows = Array.from(tempBody.children);
                                
                                if (newRows.length >= 1) {
                                    const newWrapper = newRows[0];
                                    
                                    // Insertar el nuevo wrapper en la posici√≥n correcta
                                    if (nextSibling && nextSibling.parentElement === body) {
                                        body.insertBefore(newWrapper, nextSibling);
                                    } else {
                                        body.appendChild(newWrapper);
                                    }
                                    
                                    // Aplicar el estado del toggle de miniaturas originales a la nueva fila
                                    const showOriginalCheckbox = document.getElementById('showOriginalThumbnails');
                                    if (showOriginalCheckbox) {
                                        const showOriginal = showOriginalCheckbox.checked;
                                        const newOriginalThumbCell = newWrapper.querySelector('.thumbnail-original-column');
                                        
                                        if (newOriginalThumbCell) {
                                            if (showOriginal) {
                                                newOriginalThumbCell.classList.remove('hidden');
                                            } else {
                                                newOriginalThumbCell.classList.add('hidden');
                                            }
                                        }
                                    }
                                    
                                    // No llamar a applyFilters() aqu√≠ porque re-renderiza todos los videos
                                    // La fila ya est√° actualizada y los filtros no deber√≠an cambiar
                                }
                            } else {
                                // Si no se encontraron las filas, recargar toda la p√°gina
                                console.warn('No se encontraron las filas para actualizar, recargando toda la p√°gina...');
                                setTimeout(() => {
                                    loadVideos();
                                }, 1000);
                            }
                        } else {
                            console.warn('No se encontr√≥ el video actualizado en la lista, recargando toda la p√°gina...');
                            setTimeout(() => {
                                loadVideos();
                            }, 1000);
                        }
                    } else {
                        // Si falla la obtenci√≥n de la lista, recargar toda la p√°gina
                        console.warn('Error al obtener la lista actualizada, recargando toda la p√°gina...');
                        setTimeout(() => {
                            loadVideos();
                        }, 1000);
                    }
                } else {
                    throw new Error(data.error || data.message || 'Error al actualizar contenido');
                }
            } catch (error) {
                alert(`Error al actualizar contenido: ${error.message}`);
            } finally {
                // Rehabilitar bot√≥n
                button.disabled = false;
                button.textContent = originalText;
            }
        }
        
        /**
         * Carga la informaci√≥n del canal de YouTube
         */
        async function loadYouTubeChannelInfo() {
            try {
                console.log('[YouTube Channel] Cargando informaci√≥n del canal...');
                const response = await fetch(`${API_BASE}/api/video/youtube/channel-info`);
                const data = await response.json();
                
                console.log('[YouTube Channel] Respuesta:', data);
                
                // Verificar si se requiere autenticaci√≥n (incluso si la respuesta no es exitosa)
                if (data && (data.requiresAuth || data.requiresReauth)) {
                    console.log('[YouTube Channel] Se requiere autenticaci√≥n/reautenticaci√≥n, mostrando bot√≥n de login');
                    const loginContainer = document.getElementById('youtube-login-container');
                    const loginBtn = document.getElementById('youtube-login-btn');
                    const channelInfo = document.getElementById('youtube-channel-info');
                    
                    // Ocultar informaci√≥n del canal
                    if (channelInfo) {
                        channelInfo.style.display = 'none';
                    }
                    
                    // Obtener URL de autenticaci√≥n si no est√° en la respuesta
                    let authUrl = data.authUrl;
                    if (!authUrl) {
                        // Obtener la URL de autenticaci√≥n del servidor
                        try {
                            const authResponse = await fetch(`${API_BASE}/api/video/youtube/auth-url`);
                            const authData = await authResponse.json();
                            if (authData.success && authData.authUrl) {
                                authUrl = authData.authUrl;
                            }
                        } catch (err) {
                            console.error('[YouTube Channel] Error al obtener URL de autenticaci√≥n:', err);
                        }
                    }
                    
                    // Mostrar bot√≥n de login con la URL
                    if (loginContainer && loginBtn) {
                        loginContainer.style.display = 'block';
                        if (authUrl) {
                            loginBtn.setAttribute('data-auth-url', authUrl);
                        }
                    }
                    
                    // Mostrar mensaje de error visible al usuario
                    const errorMessage = data.message || data.error || 'El token de acceso ha expirado. Por favor, autentica la aplicaci√≥n nuevamente.';
                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #FF9800; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001; max-width: 400px;';
                    errorMsg.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 20px;">‚ö†Ô∏è</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 5px;">Autenticaci√≥n de YouTube requerida</div>
                                <div style="font-size: 13px; opacity: 0.95;">${escapeHtml(errorMessage)}</div>
                            </div>
                            <button onclick="this.parentElement.parentElement.remove()" style="background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; margin-left: 10px; opacity: 0.8; hover: opacity: 1;">‚úï</button>
                        </div>
                    `;
                    document.body.appendChild(errorMsg);
                    
                    // Auto-eliminar despu√©s de 10 segundos
                    setTimeout(() => {
                        if (errorMsg.parentElement) {
                            errorMsg.remove();
                        }
                    }, 10000);
                    
                    return; // Salir de la funci√≥n
                }
                
                if (response.ok && data.success && data.channel) {
                    console.log('[YouTube Channel] Informaci√≥n del canal recibida:', data.channel);
                    const channelInfo = document.getElementById('youtube-channel-info');
                    const channelThumbnail = document.getElementById('youtube-channel-thumbnail');
                    const channelTitle = document.getElementById('youtube-channel-title');
                    const channelEmail = document.getElementById('youtube-channel-email');
                    
                    if (channelInfo && channelTitle) {
                        // Ocultar bot√≥n de login si est√° visible
                        const loginContainer = document.getElementById('youtube-login-container');
                        if (loginContainer) {
                            loginContainer.style.display = 'none';
                        }
                        
                        // Mostrar el contenedor
                        channelInfo.style.display = 'flex';
                        
                        // Configurar t√≠tulo del canal
                        channelTitle.textContent = data.channel.title || 'Canal de YouTube';
                        
                        // Configurar email si est√° disponible
                        if (data.channel.email) {
                            channelEmail.textContent = data.channel.email;
                            channelEmail.style.display = 'block';
                        } else {
                            channelEmail.textContent = '';
                            channelEmail.style.display = 'none';
                        }
                        
                        // Configurar thumbnail si est√° disponible
                        if (data.channel.thumbnail && channelThumbnail) {
                            channelThumbnail.src = data.channel.thumbnail;
                            channelThumbnail.style.display = 'block';
                            channelThumbnail.onerror = function() {
                                this.style.display = 'none';
                            };
                        } else if (channelThumbnail) {
                            channelThumbnail.style.display = 'none';
                        }
                    }
                } else {
                    console.log('[YouTube Channel] No se encontr√≥ informaci√≥n del canal en la respuesta');
                    
                    // Si no hay informaci√≥n del canal, ocultar el contenedor
                    const channelInfo = document.getElementById('youtube-channel-info');
                    const loginContainer = document.getElementById('youtube-login-container');
                    
                    if (channelInfo) {
                        channelInfo.style.display = 'none';
                    }
                    
                    // Si no se requiere autenticaci√≥n, ocultar tambi√©n el bot√≥n de login
                    if (loginContainer && !data.requiresAuth && !data.requiresReauth) {
                        loginContainer.style.display = 'none';
                    }
                    
                    // Si hay un error en la respuesta, mostrarlo
                    if (data && data.error && data.message) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #f44336; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001; max-width: 400px;';
                        errorMsg.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 20px;">‚ùå</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">Error de YouTube</div>
                                    <div style="font-size: 13px; opacity: 0.95;">${escapeHtml(data.message)}</div>
                                </div>
                                <button onclick="this.parentElement.parentElement.remove()" style="background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; margin-left: 10px; opacity: 0.8;">‚úï</button>
                            </div>
                        `;
                        document.body.appendChild(errorMsg);
                        
                        // Auto-eliminar despu√©s de 10 segundos
                        setTimeout(() => {
                            if (errorMsg.parentElement) {
                                errorMsg.remove();
                            }
                        }, 10000);
                    }
                }
            } catch (error) {
                console.error('[YouTube Channel] Error al cargar informaci√≥n del canal:', error);
                
                // Mostrar mensaje de error visible al usuario
                const errorMsg = document.createElement('div');
                errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #f44336; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 10001; max-width: 400px;';
                errorMsg.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 20px;">‚ùå</span>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 5px;">Error al cargar informaci√≥n de YouTube</div>
                            <div style="font-size: 13px; opacity: 0.95;">${escapeHtml(error.message || 'Error desconocido')}</div>
                        </div>
                        <button onclick="this.parentElement.parentElement.remove()" style="background: transparent; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; margin-left: 10px; opacity: 0.8;">‚úï</button>
                    </div>
                `;
                document.body.appendChild(errorMsg);
                
                // Auto-eliminar despu√©s de 10 segundos
                setTimeout(() => {
                    if (errorMsg.parentElement) {
                        errorMsg.remove();
                    }
                }, 10000);
                
                // Ocultar el contenedor si hay error
                const channelInfo = document.getElementById('youtube-channel-info');
                if (channelInfo) {
                    channelInfo.style.display = 'none';
                }
                
                // Ocultar bot√≥n de login tambi√©n
                const loginContainer = document.getElementById('youtube-login-container');
                if (loginContainer) {
                    loginContainer.style.display = 'none';
                }
            }
        }
        
        /**
         * Abre la URL de autenticaci√≥n de YouTube
         */
        function loginYouTube() {
            const loginBtn = document.getElementById('youtube-login-btn');
            if (loginBtn) {
                const authUrl = loginBtn.getAttribute('data-auth-url');
                let finalAuthUrl = authUrl;
                
                if (!finalAuthUrl) {
                    // Si no hay URL guardada, obtenerla del servidor
                    fetch(`${API_BASE}/api/video/youtube/auth-url`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.success && data.authUrl) {
                                finalAuthUrl = data.authUrl;
                                openAuthWindow(finalAuthUrl);
                            } else {
                                alert('Error al obtener la URL de autenticaci√≥n');
                            }
                        })
                        .catch(error => {
                            console.error('Error al obtener URL de autenticaci√≥n:', error);
                            alert('Error al obtener la URL de autenticaci√≥n');
                        });
                } else {
                    openAuthWindow(finalAuthUrl);
                }
            }
        }
        
        /**
         * Abre la ventana de autenticaci√≥n y configura el polling para verificar cuando se cierre
         */
        function openAuthWindow(authUrl) {
            // Abrir la URL de autenticaci√≥n en una nueva ventana
            const authWindow = window.open(authUrl, 'youtube_auth', 'width=600,height=700');
            
            if (authWindow) {
                // Verificar peri√≥dicamente si la ventana se cerr√≥
                const checkInterval = setInterval(() => {
                    if (authWindow.closed) {
                        clearInterval(checkInterval);
                        // Esperar un momento para que el servidor procese el token
                        setTimeout(() => {
                            // Recargar la informaci√≥n del canal
                            loadYouTubeChannelInfo();
                        }, 1000);
                    }
                }, 500);
                
                // Tambi√©n verificar si la ventana fue redirigida (m√°ximo 5 minutos)
                setTimeout(() => {
                    clearInterval(checkInterval);
                }, 5 * 60 * 1000);
            } else {
                alert('No se pudo abrir la ventana de autenticaci√≥n. Por favor, verifica que los pop-ups no est√©n bloqueados.');
            }
        }
        
        /**
         * Cierra la sesi√≥n de YouTube eliminando el token
         */
        async function logoutYouTube() {
            if (!confirm('¬øEst√°s seguro de que deseas cerrar la sesi√≥n de YouTube?\n\nEsto eliminar√° el token de autenticaci√≥n y tendr√°s que volver a autenticarte para subir videos.')) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/video/youtube/logout`, {
                    method: 'POST',
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Ocultar la informaci√≥n del canal
                    const channelInfo = document.getElementById('youtube-channel-info');
                    if (channelInfo) {
                        channelInfo.style.display = 'none';
                    }
                    
                    // Recargar la informaci√≥n del canal para mostrar el bot√≥n de login
                    loadYouTubeChannelInfo();
                    
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Sesi√≥n de YouTube cerrada exitosamente';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                } else {
                    throw new Error(data.error || data.message || 'Error al cerrar sesi√≥n');
                }
            } catch (error) {
                console.error('Error al cerrar sesi√≥n de YouTube:', error);
                alert(`Error al cerrar sesi√≥n: ${error.message}`);
            }
        }
        
        // Verificar si viene de una autenticaci√≥n exitosa de YouTube
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('youtube_auth') === 'success') {
            // Mostrar mensaje de √©xito
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
            successMsg.textContent = '‚úÖ Autenticaci√≥n de YouTube exitosa';
            document.body.appendChild(successMsg);
            
            setTimeout(() => {
                successMsg.remove();
            }, 3000);
            
            // Limpiar el par√°metro de la URL sin recargar la p√°gina
            window.history.replaceState({}, document.title, window.location.pathname);
        }
        
        // Cargar videos al cargar la p√°gina
        loadVideos();
        // Cargar informaci√≥n del canal de YouTube
        loadYouTubeChannelInfo();
        
        // Escuchar mensajes del popup de autenticaci√≥n de YouTube
        window.addEventListener('message', function(event) {
            // Verificar que el mensaje sea del tipo correcto
            if (event.data && event.data.type === 'youtube_auth_success') {
                console.log('[YouTube Auth] Mensaje de autenticaci√≥n exitosa recibido del popup');
                // Esperar un momento para que el servidor procese el token
                setTimeout(() => {
                    // Recargar la informaci√≥n del canal
                    loadYouTubeChannelInfo();
                    // Mostrar mensaje de √©xito
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 1000;';
                    successMsg.textContent = '‚úÖ Autenticaci√≥n de YouTube exitosa';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                }, 1000);
            }
        });
    </script>

    <!-- Bot√≥n flotante para actualizar todos los videos -->
    <button id="refresh-all-floating-btn" class="refresh-all-floating-btn" onclick="refreshAllVideos()">
        üîÑ Actualizar Todo
    </button>
    
    <!-- Bot√≥n flotante para combinar videos seleccionados -->
    <button id="combine-floating-btn" class="combine-floating-btn" onclick="combineSelectedVideos()">
        üîó Combinar
    </button>
</body>
</html>
